//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by Measurement Studio for ni568x 15.0.
//     Runtime Version:2.0.50727.3615
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace NationalInstruments.ModularInstruments.Interop
{
    using System;
    using System.Runtime.InteropServices;

    /// <summary>
    /// 
    /// </summary>
    public class ni568x : object, System.IDisposable
    {

        private System.Runtime.InteropServices.HandleRef _handle;
        /// <summary>
        /// 
        /// </summary>
        private bool _disposed = true;
        /// <summary>
        /// 
        /// </summary>
        ~ni568x() { Dispose(false); }


        /// <summary>
        /// This function creates an IVI instrument driver session, typically using the C session instrument handle.
        /// </summary>
        /// <param name="Instrument_Handle">
        /// The instrument handle that is used to create an IVI instrument driver session.
        /// </param>
        public ni568x(System.IntPtr Instrument_Handle)
        {
            this._handle = new System.Runtime.InteropServices.HandleRef(this, Instrument_Handle);
            this._disposed = false;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_init
        /// 
        /// ni568x_init(ViRsrc          resourceName,
        ///     ViBoolean       IDQuery,
        ///     ViBoolean       resetDevice,
        ///     ViSession*      vi
        /// );
        /// 
        /// Purpose
        /// 
        /// Performs the following initialization actions:
        /// 
        /// Creates a new IVI NI-568x session.
        /// Opens a new I/O session, using the interface and address you specify for resourceName.
        /// Queries the device ID and checks that it is valid for NI-568x if IDQuery is set to VI_TRUE.
        /// Resets the device to a known state if resetDevice is set to VI_TRUE.
        /// Sends initialization commands to set the device to the state necessary to run NI-568x applications.
        /// Returns an instrumentHandle that you use to identify the device in all subsequent instrument driver function calls.
        /// 
        /// 
        /// Note&#160;&#160;This function creates a new session each time you invoke it. Although you can open more than one IVI session for the same resource, NI does not recommend doing so. Instead, use the same session in multiple program threads. 
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </summary>
        /// <param name="Resource_Name">
        /// 
        /// 
        /// resourceName
        /// ViRsrc
        /// Specifies the resource name of the device, obtained from Measurement &amp; Automation Explorer (MAX), to initialize. You can also pass a logical name that you configure with the IVI Configuration utility.
        /// 
        /// 
        /// 
        /// 
        /// The following list shows the syntax to use for resourceName. Optional fields are shown in square brackets ([]).
        /// 
        /// 
        /// 
        /// 
        /// COM&lt;port&gt;
        /// ASRL&lt;port&gt;[::INSTR]
        /// &lt;LogicalName&gt;
        /// 
        /// 
        /// 
        /// 
        /// NI-568x uses the VISA I/O library to communicate with the NI-568x device through a virtual serial (COM) port associated with the USB port of the device to which it is connected. The COM port for your device is shown in MAX, under Devices and Interfaces.
        /// 
        /// 
        /// 
        /// 
        /// 
        /// Example values for resourceName are shown in the following table.
        /// 
        /// 
        /// 
        /// Valid ValueDescription
        /// COM3
        /// COM port 3
        /// ASRL2::INSTR
        /// COM port 2
        /// SampleInstr
        /// Logical name "SampleInstr"
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="ID_Query">
        /// 
        /// 
        /// IDQuery
        /// ViBoolean
        /// Specifies whether NI-568x performs an ID query. When you perform an ID query, NI-568x verifies the device you initialize is supported.
        /// 
        /// 
        /// When you set this parameter to VI_TRUE (Yes), the driver verifies that the device you initialize is a type that this driver supports. When you perform an ID query, NI-568x verifies the device you initialize is supported. When you set this parameter to VI_FALSE, the function initializes the device without performing an ID query.
        /// 
        /// 
        /// 
        /// Circumstances can arise where it is undesirable to send an ID query command string to the device.
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Reset_Device">
        /// 
        /// 
        /// resetDevice
        /// ViBoolean
        /// Specifies whether the device is reset during the initialization procedure.
        /// 
        /// 
        /// 
        /// The valid values are VI_TRUE (1, the device is reset) and VI_FALSE (0, the device is not reset). The default value is VI_TRUE.
        /// 
        /// </param>
        public ni568x(string Resource_Name, bool ID_Query, bool Reset_Device)
        {
            System.IntPtr instrumentHandle;
            int pInvokeResult = PInvoke.init(Resource_Name, System.Convert.ToUInt16(ID_Query), System.Convert.ToUInt16(Reset_Device), out instrumentHandle);
            this._handle = new System.Runtime.InteropServices.HandleRef(this, instrumentHandle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            this._disposed = false;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_InitWithOptions
        /// 
        /// ni568x_InitWithOptions(ViRsrc          resourceName,
        ///     ViBoolean       IDQuery,
        ///     ViBoolean       resetDevice,
        ///     ViConstString   optionString,
        ///     ViSession      *newVi
        /// );
        /// 
        /// Purpose
        /// 
        /// Performs the following initialization actions:
        /// 
        /// Creates a new IVI NI-568x session and optionally sets the initial state of the following session attributes:
        /// NI568X_ATTR_RANGE_CHECK
        /// NI568X_ATTR_QUERY_INSTRUMENT_STATUS
        /// NI568X_ATTR_CACHE
        /// NI568X_ATTR_SIMULATE
        /// NI568X_ATTR_RECORD_COERCIONS
        /// NI568X_ATTR_DRIVER_SETUP
        /// Opens a new I/O session, using the interface and address you specify for resourceName.
        /// Queries the device ID and checks that it is valid for NI-568x if IDQuery is set to VI_TRUE.
        /// Resets the device to a known state if resetDevice is set to VI_TRUE.
        /// Sends initialization commands to set the device to the state necessary to run NI-568x applications.
        /// Returns an instrumentHandle that you use to identify the device in all subsequent NI-568x function calls.
        /// 
        /// 
        /// Note&#160;&#160;This function creates a new session each time you invoke it. Although you can open more than one IVI session for the same resource, NI does not recommend doing so. Instead, use the same session in multiple program threads. 
        /// 
        /// Use the ni568x_LockSession function and the ni568x_UnlockSession function to protect sections of code that require exclusive access to the resource.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// 
        /// 
        /// </summary>
        /// <param name="Resource_Name">
        /// 
        /// 
        /// resourceName
        /// ViRsrc
        /// Specifies the resource name of the device, obtained from Measurement &amp; Automation Explorer (MAX), to initialize. You can also pass a logical name that you configure with the IVI Configuration utility.
        /// 
        /// 
        /// 
        /// 
        /// The following list shows the syntax to use for resourceName. Optional fields are shown in square brackets ([]).
        /// 
        /// 
        /// 
        /// 
        /// COM&lt;port&gt;
        /// ASRL&lt;port&gt;[::INSTR]
        /// &lt;LogicalName&gt;
        /// 
        /// 
        /// 
        /// 
        /// NI-568x uses the VISA I/O library to communicate with the NI-568x device through a virtual serial (COM) port associated with the USB port of the device to which it is connected. The COM port for your device is shown in MAX, under Devices and Interfaces.
        /// 
        /// 
        /// 
        /// 
        /// 
        /// Example values for resourceName are shown in the following table.
        /// 
        /// 
        /// 
        /// Valid ValueDescription
        /// COM3
        /// COM port 3
        /// ASRL2::INSTR
        /// COM port 2
        /// SampleInstr
        /// Logical name "SampleInstr"
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="ID_Query">
        /// 
        /// 
        /// IDQuery
        /// ViBoolean
        /// Specifies whether NI-568x performs an ID query. When you perform an ID query, NI-568x verifies the device you initialize is supported.
        /// 
        /// 
        /// When you set this parameter to VI_TRUE (Yes), the driver verifies that the device you initialize is a type that this driver supports. When you perform an ID query, NI-568x verifies the device you initialize is supported. When you set this parameter to VI_FALSE, the function initializes the device without performing an ID query.
        /// 
        /// 
        /// 
        /// Circumstances can arise where it is undesirable to send an ID query command string to the device.
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Reset_Device">
        /// 
        /// 
        /// resetDevice
        /// ViBoolean
        /// Specifies whether the device is reset during the initialization procedure.
        /// 
        /// 
        /// 
        /// The valid values are VI_TRUE (1, the device is reset) and VI_FALSE (0, the device is not reset). The default value is VI_TRUE.
        /// 
        /// </param>
        /// <param name="Option_String">
        /// 
        /// 
        /// optionString
        /// ViConstString
        /// Initializes the initial value of certain attributes for the session. The following table lists the attributes and the label name you use in optionString to identify the attribute.
        /// 
        /// 
        /// 
        /// Attribute Defined Constant
        /// Label Name
        /// NI568X_ATTR_SIMULATE
        /// Simulate
        /// NI568X_ATTR_RANGE_CHECK
        /// RangeCheck
        /// NI568X_ATTR_QUERY_INSTRUMENT_STATUS
        /// QueryInstrStatus
        /// NI568X_ATTR_CACHE
        /// Cache
        /// NI568X_ATTR_RECORD_COERCIONS
        /// RecordCoercions
        /// NI568X_ATTR_DRIVER_SETUP
        /// DriverSetup
        /// 
        /// 
        /// 
        /// 
        /// The format of this string is, AttributeName=Value, where AttributeName is the label name of the attribute and Value is the value to which the attribute is set. To set multiple attributes, separate their assignments with a comma.
        /// 
        /// 
        /// 
        /// If you pass NULL, an empty string, or if you do not specify a value, the session uses the attributes' default values. To override the default values, assign a value explicitly in a string you pass for optionString. You do not have to specify all of the attributes and may omit any of them.
        /// 
        ///   
        /// 
        /// The default values for the attributes are shown in the following table.
        /// 
        /// 
        /// 
        /// Label Name
        /// Default Value
        /// Simulate
        /// VI_FALSE
        /// RangeCheck
        /// VI_TRUE
        /// QueryInstrStatus
        /// VI_FALSE
        /// Cache
        /// VI_TRUE
        /// RecordCoercions
        /// VI_FALSE
        /// DriverSetup
        /// &quot;&quot;
        /// 
        /// 
        /// 
        /// 
        /// The default value is "Simulate=0,RangeCheck=1,QueryInstrStatus=0,Cache=1".
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </param>
        public ni568x(string Resource_Name, bool ID_Query, bool Reset_Device, string Option_String)
        {
            System.IntPtr instrumentHandle;
            int pInvokeResult = PInvoke.InitWithOptions(Resource_Name, System.Convert.ToUInt16(ID_Query), System.Convert.ToUInt16(Reset_Device), Option_String, out instrumentHandle);
            this._handle = new System.Runtime.InteropServices.HandleRef(this, instrumentHandle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            this._disposed = false;
        }

        /// <summary>
        /// Gets the instrument handle.
        /// </summary>
        /// <value>
        /// The value is the IntPtr that represents the handle to the instrument.
        /// </value>
        public HandleRef Handle
        {
            get
            {
                return this._handle;
            }
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ConfigureAcquisitionMode
        /// 
        /// ni568x_ConfigureAcquisitionMode(ViSession vi, ViConstString channel, ViInt32 mode);
        /// 
        /// Purpose
        /// 
        /// Configure the acquisition mode of NI-568x driver. Some functions are available only with certain acquisition modes. The NI 5680 supports only Continuous acquisition mode.
        /// 
        /// Supported Devices: NI 5680/5681
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel you want to configure.
        /// 
        /// 
        /// The only valid value is &quot;0&quot;.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Mode">
        /// 
        /// 
        /// mode
        /// ViInt32
        /// Specifies the operating mode for the NI-568x device.
        /// 
        /// 
        /// 
        /// NI568X_VAL_CONTINUOUS_MODE (10000)
        /// Continuous mode is the standard power meter measuring mode. In Continuous mode, the power meter starts measuring power immediately after the operation is initiated and continues until you stop the operation.
        /// NI568X_VAL_TIME_SLOT_MODE (20000)
        /// In Time Slot mode, an internal or external trigger initiates the power sensor, which divides the power measurement into the time slots you define for the measurement and calculates the average power reading for each individual slot. 
        /// NI568X_VAL_SCOPE_MODE (30000)
        /// In Scope mode, an internal or external trigger initiates the power sensor measurement with respect to time. You can configure a gate and a fence for the measurement to control which portion of the time domain data is recorded. 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureAcquisitionMode(string Channel_Name, int Mode)
        {
            int pInvokeResult = PInvoke.ConfigureAcquisitionMode(this._handle, Channel_Name, Mode);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// 
        /// ni568x_ConfigureUnits
        /// 
        /// ni568x_ConfigureUnits(ViSession vi, ViInt32 units);
        /// 
        /// Purpose
        /// 
        /// Configures the units NI-568x uses to return measured values.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <param name="Units">
        /// 
        /// 
        /// units
        /// ViInt32
        /// Specifies the units NI-568x uses to return measured values. NI-568x sets the NI568X_ATTR_UNITS attribute to this value.
        /// 
        /// 
        /// 
        /// The units of the values obtained from the ni568x_Read function and the ni568x_Fetch function reflect the value set in this parameter.
        /// 
        /// 
        /// 
        /// The following are the valid values for this parameter:
        /// 
        /// 
        /// 
        /// 
        /// 
        /// NI568X_VAL_DBM (1)
        /// Sets the units to dBm. This value is the default.
        /// NI568X_VAL_WATTS (4)
        /// Sets the units to watts.
        /// NI568X_VAL_MWATTS (1001)
        /// Sets the units to milliwatts.
        /// NI568X_VAL_UWATTS (1002)
        /// Sets the units to microwatts.
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureUnits(int Units)
        {
            int pInvokeResult = PInvoke.ConfigureUnits(this._handle, Units);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// 
        /// ni568x_ConfigureMeasurement
        /// 
        /// ni568x_ConfigureMeasurement(ViSession vi, ViInt32 mathOperator, ViConstString channelNameOne, ViConstString channelNameTwo);
        /// 
        /// Purpose
        /// 
        /// Configures the device to take single-channel or dual-channel measurements.
        /// 
        /// 
        /// Note&#160;&#160;Dual-channel measurements currently are not supported. The IVI Power Meter class requirements require that this function be included in NI-568x.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <param name="Math_Operator">
        /// 
        /// 
        /// mathOperator
        /// ViInt32
        /// Determines the type of operation to perform on two channels.
        /// 
        /// 
        /// 
        /// Currently, the only valid value for this parameter is NI568X_VAL_NONE (0).
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Channel_Name_One">
        /// 
        /// 
        /// channelNameOne
        /// ViConstString
        /// Specifies the channel name of the first channel.
        /// 
        /// 
        /// The only valid channel name is &quot;0&quot;.
        /// 
        /// </param>
        /// <param name="Channel_Name_Two">
        /// 
        /// 
        /// channelNameTwo
        /// ViConstString
        /// Specifies the channel name of the second channel.
        /// 
        /// 
        /// The only valid channel name is &quot;0&quot;.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureMeasurement(int Math_Operator, string Channel_Name_One, string Channel_Name_Two)
        {
            int pInvokeResult = PInvoke.ConfigureMeasurement(this._handle, Math_Operator, Channel_Name_One, Channel_Name_Two);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ConfigureRangeAutoEnabled
        /// 
        /// ni568x_ConfigureRangeAutoEnabled(ViSession vi, ViConstString channelName, ViBoolean rangeAutoEnabled);
        /// 
        /// Purpose
        /// 
        /// Enables or disables auto-ranging on the channel specified in the channelName parameter. Auto-ranging means that the sensor firmware determines the appropriate range for sensor operation. If you disable auto-ranging, specify the range using the ni568x_ConfigureRange function. 
        /// 
        /// 
        /// Supported Devices: NI&#160;5681
        /// 
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel you want to configure.
        /// 
        /// 
        /// The only valid value is &quot;0&quot;.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Range_Auto_Enabled">
        /// 
        /// 
        /// rangeAutoEnabled
        /// ViBoolean
        /// Specifies whether the NI-568x device automatically determines the optimal measurement range of power.
        /// 
        /// 
        /// VI_TRUE (On)
        /// Auto-ranging is enabled. The NI&#160;5680 supports only TRUE for this property. This value is the default.
        /// VI_FALSE (Off)
        /// Auto-ranging is not enabled.
        /// 				
        /// 			
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureRangeAutoEnabled(string Channel_Name, bool Range_Auto_Enabled)
        {
            int pInvokeResult = PInvoke.ConfigureRangeAutoEnabled(this._handle, Channel_Name, System.Convert.ToUInt16(Range_Auto_Enabled));
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ConfigureAveragingAutoEnabled
        /// 
        /// ni568x_ConfigureAveragingAutoEnabled(ViSession       vi,
        ///     ViConstString   channelName,
        ///     ViBoolean       averagingAutoEnabled);
        /// 
        /// Purpose
        /// 
        /// This VI enables or disables the auto-averaging. When auto-averaging is enabled, the sensor chooses an averaging number based on the power level currently being measured. For most power levels, enabling auto-averaging results in the power reading fluctuating by no more than twice the value you select for the NI568X_ATTR_AUTO_AVERAGE_RESOLUTION attribute. Auto-averaging only stabilizes the readings due to noise contributed by the power sensor electronics. 
        /// 
        /// If you disable auto-averaging, you can configure the number of samples to average using the ni568x_ConfigureAveragingCount function.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel you want to configure.
        /// 
        /// 
        /// The only valid value is &quot;0&quot;.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Averaging_Auto_Enabled">
        /// 
        /// 
        /// averagingAutoEnabled
        /// ViBoolean
        /// Enables or disables the auto-averaging mode used for the channel you specify in channelName. NI-568x sets the NI568X_ATTR_AVERAGING_AUTO_ENABLED attribute to this value.
        /// 
        /// 
        /// 
        /// When auto-averaging is disabled, you must specify the number of samples that NI-568x averages by calling the ni568x_ConfigureAveragingCount function.
        /// 
        /// 
        /// 
        /// VI_TRUE (On)
        /// Enables auto-averaging.
        /// VI_FALSE (Off)
        /// Disables auto-averaging. This value is the default.
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureAveragingAutoEnabled(string Channel_Name, bool Averaging_Auto_Enabled)
        {
            int pInvokeResult = PInvoke.ConfigureAveragingAutoEnabled(this._handle, Channel_Name, System.Convert.ToUInt16(Averaging_Auto_Enabled));
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ConfigureCorrectionFrequency
        /// 
        /// ni568x_ConfigureCorrectionFrequency(ViSession vi,ViConstString channelName, ViReal64 frequency);
        /// 
        /// Purpose
        /// 
        /// Specifies the frequency, in hertz (Hz), of the input signal. NI-568x uses the frequency value to determine the power meter sensor correction factor. Use this function to tell NI-568x which input signal frequency needs correction.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel you want to configure.
        /// 
        /// 
        /// The only valid value is &quot;0&quot;.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Frequency">
        /// 
        /// 
        /// frequency
        /// ViReal64
        /// Specifies the frequency, in hertz (Hz), of the input signal. The NI-568x device uses this value to determine the appropriate power meter sensor correction factor. To obtain the most accurate measurement, set the frequency value as close as possible to the actual input signal frequency. NI-568x sets the NI568X_ATTR_CORRECTION_FREQUENCY attribute to this value.
        /// 
        /// 
        /// Valid Range:
        /// 
        /// 
        /// NI 5680: The valid values range from 50.0 MHz (specified by 50.0E6 or 50000000) to 6.0 GHz (specified by 6.0E9 or 6000000000).
        /// 
        /// 
        /// NI 5681: The valid values range from 10.0 MHz (specified by 10.0E6 or 10000000) to 18.0 GHz (specified by 18.0E9 or 18000000000).
        /// 
        /// 
        /// Default Value: 50.0E6
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureCorrectionFrequency(string Channel_Name, double Frequency)
        {
            int pInvokeResult = PInvoke.ConfigureCorrectionFrequency(this._handle, Channel_Name, Frequency);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ConfigureOffset
        /// 
        /// ni568x_ConfigureOffset(ViSession vi, ViConstString channelName, ViReal64 offset);
        /// 
        /// Purpose
        /// 
        /// Specifies the offset, in decibels (dB), to apply to the measured value.
        /// 
        /// NI-568x uses the offset to compensate for system losses or gains between the device under test and the power meter sensor. A positive value is used for loss compensation. A negative value is used for gain compensation. For example, you can compensate for a cable loss of 2 dB by setting offset to 2. Similarly, you can compensate for a gain stage of 10 dB by setting offset to -10.  In both cases, the NI-568x reading indicates the power at the device under test rather than the power at the NI-568x device.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel you want to configure.
        /// 
        /// 
        /// The only valid value is &quot;0&quot;.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Offset">
        /// 
        /// 
        /// offset
        /// ViReal64
        /// Specifies the offset for the measured value. NI-568x sets the NI568X_ATTR_OFFSET attribute to this value.
        /// 
        /// 
        /// Valid Range: -100 to 100
        /// 
        /// 
        /// Default Value: 0.0
        /// 
        /// 
        /// Note??You specify the offset in dB regardless of the value of the NI568X_ATTR_UNITS attribute. 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureOffset(string Channel_Name, double Offset)
        {
            int pInvokeResult = PInvoke.ConfigureOffset(this._handle, Channel_Name, Offset);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ConfigureRange
        /// 
        /// ni568x_ConfigureRange(ViSession       vi,
        ///     ViConstString   channelName,
        ///     ViReal64        rangeLower,
        ///     ViReal64        rangeUpper);
        /// 
        /// Purpose
        /// 
        /// Configures the lower and upper range values for a given channel. The supported ranges for the NI RF power meter are located in the specifications document for your device. NI-568x coerces the values passed to this function to a valid device range.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel you want to configure.
        /// 
        /// 
        /// The only valid value is &quot;0&quot;.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Range_Lower">
        /// 
        /// 
        /// rangeLower
        /// ViReal64
        /// Specifies the lower limit of the expected value of the measurement. The value of this attribute is specified in the same units as specified with the NI568X_ATTR_UNITS attribute.
        /// 
        /// 
        /// </param>
        /// <param name="Range_Upper">
        /// 
        /// 
        /// rangeUpper
        /// ViReal64
        /// Specifies the upper limit of the expected value of the measurement. The value of this attribute is specified in the same units as specified with the NI568X_ATTR_UNITS attribute.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureRange(string Channel_Name, double Range_Lower, double Range_Upper)
        {
            int pInvokeResult = PInvoke.ConfigureRange(this._handle, Channel_Name, Range_Lower, Range_Upper);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// 
        /// 
        /// ni568x_ConfigureAveragingCount
        /// 
        /// ni568x_ConfigureAveragingCount(ViSession       vi,
        ///     ViConstString   channelName,
        ///     ViInt32         averagingCount);
        /// 
        /// Purpose
        /// 
        /// Sets the averaging count that NI-568x uses with repeat averaging. The averagingCount parameter specifies the number of samples the NI-568x device takes before completing the measurement.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel you want to configure.
        /// 
        /// 
        /// The only valid value is &quot;0&quot;.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Averaging_Count">
        /// 
        /// 
        /// averagingCount
        /// ViInt32
        /// Specifies the averaging count, which is the number of samples the NI-568x device takes before completing the measurement. NI-568x sets the NI568X_ATTR_AVERAGING_COUNT attribute to this value. 
        /// 
        /// 
        /// 
        /// 
        /// Valid Values:
        /// 
        /// 
        /// NI 5680: 1 to 256
        /// 
        /// 
        /// NI 5681: 1 to 40000
        /// 
        /// 
        /// Default Value: 1
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureAveragingCount(string Channel_Name, int Averaging_Count)
        {
            int pInvokeResult = PInvoke.ConfigureAveragingCount(this._handle, Channel_Name, Averaging_Count);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ConfigureDutyCycleCorrection
        /// 
        /// ni568x_ConfigureDutyCycleCorrection(ViSession       vi,
        ///     ViConstString   channelName,
        ///     ViBoolean       correctionEnabled,
        ///     ViReal64        correction);
        /// 
        /// Purpose
        /// 
        /// Enables or disables the duty cycle correction and configures the duty cycle correction for pulse power measurements.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel you want to configure.
        /// 
        /// 
        /// The only valid value is &quot;0&quot;.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Correction_Enabled">
        /// 
        /// 
        /// correctionEnabled
        /// ViBoolean
        /// Specifies if the power meter performs a duty cycle correction on the specified channel.
        /// 
        /// 
        /// VI_TRUE (On)
        /// Enables duty cycle correction.
        /// VI_FALSE (Off)
        /// Disables duty cycle correction. This value is the default.
        /// 
        /// </param>
        /// <param name="Correction">
        /// 
        /// 
        /// correction
        /// ViReal64
        /// Specifies the duty cycle correction the power meter uses to calculate the pulse power of a pulse-modulated signal. The duty cycle indicates the percentage of time a signal is active high, so specifying a higher value indicates that the device expects the measured signal to be active high a greater portion of the time. The value of this parameter is specified as a percentage.
        /// 
        /// 
        /// 
        /// Valid Values: 0.01 to 100
        /// Default Value: 100
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureDutyCycleCorrection(string Channel_Name, bool Correction_Enabled, double Correction)
        {
            int pInvokeResult = PInvoke.ConfigureDutyCycleCorrection(this._handle, Channel_Name, System.Convert.ToUInt16(Correction_Enabled), Correction);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_GetChannelName
        /// 
        /// ni568x_GetChannelName(ViSession       vi,
        ///     ViInt32         index,
        ///     ViInt32         bufferSize,
        ///     ViChar[]        name);
        /// 
        /// Purpose
        /// 
        /// Returns the name of the physical channel that corresponds to the specific driver channel string in the channel table at the index  specified in the index parameter. By passing 0 for bufferSize, you can ascertain the size of the buffer required to get the entire channel name string and then call the function again with a sufficiently large buffer.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// 
        /// 
        /// </summary>
        /// <param name="Index">
        /// 
        /// 
        /// index
        /// ViInt32
        /// Specifies a one-based index into the channel table. The default value is 1.
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Buffer_Size">
        /// 
        /// 
        /// bufferSize
        /// ViInt32
        /// Indicates the number of bytes in the ViChar array that you specify for attributeValue.  
        /// 
        /// If the current value of the attribute, including the terminating NULL byte, is larger than the size you indicate in bufferSize, the function copies bufferSize - 1 bytes into the buffer, places an ASCII NULL byte at the end of the buffer, and returns the size of the buffer that you must pass to get the entire value. For example, if the value is "123456" and the bufferSize is 4, the function places "123" into the buffer and returns 7.
        /// 
        /// 
        /// 
        /// 
        /// If you pass a negative number to this parameter, the function copies the value to the buffer regardless of the number of bytes in the value.
        /// 
        /// 
        /// 
        /// 
        /// If you pass 0 to this parameter, you can pass VI_NULL for the attributeValue buffer parameter.
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Name">
        /// 
        /// 
        /// name
        /// ViChar[]
        /// Returns the highest-level channel name that corresponds to the specific driver channel string in the channel table at an index you specify.
        /// 
        /// 
        /// 
        /// 
        /// The buffer must contain at least as many elements as the value you specify with the bufferSize parameter. If the current value of the attribute, including the terminating NULL byte, is larger than the size you indicate in bufferSize, the function copies bufferSize - 1 bytes into the buffer, places an ASCII NULL byte at the end of the buffer, and returns the size of the buffer that you must pass to get the entire value. For example, if the value is "123456" and the bufferSize is 4, the function places "123" into the buffer and returns 7.
        /// 
        /// 
        /// 
        /// 
        /// If you pass 0 to the bufferSize parameter, you can pass VI_NULL for this parameter.
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// statusOrRequiredSize
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// 
        /// If the current value of the attribute, including the terminating NULL byte, is larger than the size you indicate in bufferSize, the function copies bufferSize - 1 bytes into the buffer, places an ASCII NULL byte at the end of the buffer, and returns the size of the buffer that you must pass to get the entire value. For example, if the value is "123456" and the bufferSize is 4, the function places "123" into the buffer and returns 7.
        /// 
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.          
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int GetChannelName(int Index, int Buffer_Size, System.Text.StringBuilder Name)
        {
            int pInvokeResult = PInvoke.GetChannelName(this._handle, Index, Buffer_Size, Name);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ConfigureTriggerSource
        /// 
        /// ni568x_ConfigureTriggerSource(ViSession       vi,
        ///     ViInt32         triggerSource);
        /// 
        /// Purpose
        /// 
        /// Configures the type of trigger source for the RF power meter. Some functions are only available with certain trigger sources.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Trigger_Source">
        /// 
        /// 
        /// triggerSource
        /// ViInt32
        /// Specifies the trigger source.
        /// 
        /// 
        /// 
        /// NI568X_VAL_IMMEDIATE&#160;(1)
        /// The device does not wait for a trigger and makes the measurement immediately. This value is the default.
        /// NI568X_VAL_EXTERNAL&#160;(2)
        /// The device starts an acquisition based on the signal on the external trigger input terminal meeting specified criteria, such as slope, and trigger delay.
        /// NI568X_VAL_INTERNAL&#160;(3)
        /// The device starts an acquisition based on the input signal you are measuring meeting specified criteria, such as slope, level, trigger delay, and trigger noise immunity.
        /// NI568X_VAL_SOFTWARE&#160;(4)
        /// The device waits for a software trigger. After configuring the trigger type, you assert this trigger by calling the ni568x_SendSoftwareTrigger function.
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureTriggerSource(int Trigger_Source)
        {
            int pInvokeResult = PInvoke.ConfigureTriggerSource(this._handle, Trigger_Source);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ConfigureInternalTrigger
        /// 
        /// ni568x_ConfigureInternalTrigger(ViSession       vi,
        ///     ViConstString   sourceChannelName,
        ///     ViInt32         slope);
        /// 
        /// Purpose
        /// 
        /// Configures the internal trigger source and slope of the power meter.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Source_Channel_Name">
        /// 
        /// 
        /// sourceChannelName
        /// ViConstString
        /// Specifies the name of the channel to use as the internal trigger event source. The NI&#160;5681 only has one channel, so specify "0" as the value of this control.
        /// 
        /// 
        /// </param>
        /// <param name="Slope">
        /// 
        /// 
        /// 
        /// slope
        /// ViInt32
        /// Specifies the polarity of the internal trigger slope.
        /// 
        /// 
        /// 
        /// NI568X_VAL_POSITIVE
        /// Sets the trigger event to occur on the rising edge (a transition from low to high) of the trigger pulse.
        /// NI568X_VAL_NEGATIVE
        /// Sets the trigger event to occur on the falling edge (a transition from high to low) of the trigger pulse.
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureInternalTrigger(string Source_Channel_Name, int Slope)
        {
            int pInvokeResult = PInvoke.ConfigureInternalTrigger(this._handle, Source_Channel_Name, Slope);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ConfigureInternalTriggerLevel
        /// 
        /// ni568x_ConfigureInternalTriggerLevel(ViSession       vi,
        ///     ViReal64        triggerLevel);
        /// 
        /// Purpose
        /// Configures the internal trigger level of the power meter.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Trigger_Level">
        /// 
        /// 
        /// triggerLevel
        /// ViReal64
        /// Specifies the trigger level for the measurement signal.  The value of this parameter is specified in the same unit as the value of the NI568X_ATTR_UNITS attribute.
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureInternalTriggerLevel(double Trigger_Level)
        {
            int pInvokeResult = PInvoke.ConfigureInternalTriggerLevel(this._handle, Trigger_Level);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ConfigureExternalTrigger
        /// 
        /// ni568x_ConfigureExternalTrigger(ViSession       vi,
        ///     ViConstString   sourceChannelName,
        ///     ViInt32         slope);
        /// 
        /// Purpose
        /// Configures the external trigger source and slope of the power meter.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Source_Channel_Name">
        /// 
        /// 
        /// sourceChannelName
        /// ViConstString
        /// Specifies the name of the channel to use as the external trigger source. The NI&#160;5681 has only one external trigger input terminal, so specify "TTL0" or &quot;0&quot; as the value of this control.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Slope">
        /// 
        /// 
        /// slope
        /// ViInt32
        /// Specifies the polarity of the external trigger slope.
        /// 
        /// 
        /// 
        /// NI568X_VAL_POSITIVE
        /// Sets the trigger event to occur on the rising edge (a transition from low to high) of the trigger pulse. This value is the default.
        /// NI568X_VAL_NEGATIVE
        /// Sets the trigger event to occur on the falling edge (a transition from high to low) of the trigger pulse.
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureExternalTrigger(string Source_Channel_Name, int Slope)
        {
            int pInvokeResult = PInvoke.ConfigureExternalTrigger(this._handle, Source_Channel_Name, Slope);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ConfigureTriggerDelay
        /// 
        /// ni568x_ConfigureTriggerDelay(ViSession       vi,
        ///     ViBoolean       triggerDelayEnabled,
        ///     ViReal64        triggerDelayTime);
        /// 
        /// Purpose
        /// 
        /// Configures the delay between the trigger and the actual measurement.
        /// 
        /// You can configure a trigger delay only when the triggerSource parameter of the ni568x_ConfigureTriggerSource function is set to NI568X_VAL_INTERNAL or NI568X_VAL_EXTERNAL.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Trigger_Delay_Enabled">
        /// 
        /// 
        /// triggerDelayEnabled
        /// ViBoolean
        /// Specifies if the RF power meter uses a trigger delay when making a triggered measurement.
        /// 
        /// 
        /// 
        /// VI_TRUE&#160;(On)
        /// Specifies that the RF power meter uses a delay.
        /// VI_FALSE&#160;(Off)
        /// Specifies that the RF power meter does not use a delay. This value is the default.
        /// 
        /// 
        /// </param>
        /// <param name="Trigger_Delay_Time">
        /// 
        /// 
        /// triggerDelayTime
        /// ViReal64
        /// Specifies the trigger delay time in seconds. A negative delay means the sensor takes measurements before the trigger occurs.
        /// 
        /// 
        /// Valid Values: -5e-3 to 10
        /// 
        /// 
        /// Default Values: 0.0
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureTriggerDelay(bool Trigger_Delay_Enabled, double Trigger_Delay_Time)
        {
            int pInvokeResult = PInvoke.ConfigureTriggerDelay(this._handle, System.Convert.ToUInt16(Trigger_Delay_Enabled), Trigger_Delay_Time);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ConfigureTriggerNoiseImmunity
        /// 
        /// ni568x_ConfigureTriggerNoiseImmunity(ViSession       vi,
        ///     ViBoolean       triggerImmunityEnabled,
        ///     ViInt32         triggerImmunityfactor);
        /// 
        /// Purpose
        /// 
        /// Configures the sensor to wait for the trigger immunity factor, which is a specified number of data points to cross the triggering threshold, before asserting the actual trigger.
        /// 
        /// You can configure a trigger immunity factor only when the triggerSource parameter of the ni568x_ConfigureTriggerSource function is set to NI568X_VAL_INTERNAL.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Trigger_Immunity_Enabled">
        /// 
        /// 
        /// triggerImmunityEnabled
        /// ViBoolean
        /// Specifies if the trigger noise immunity factor is used when triggering.
        /// 
        /// 
        /// VI_TRUE&#160;(On)
        /// Specifies that the trigger noise immunity factor is used.
        /// VI_FALSE&#160;(Off)
        /// Specifies that the trigger noise immunity factor is not used. This value is the default.
        /// 
        /// 
        /// </param>
        /// <param name="Trigger_Immunity_Factor">
        /// 
        /// 
        /// triggerImmunityFactor
        /// ViInt32
        /// Specifies the number of data points that must cross the triggering threshold before the trigger is recognized.
        /// 
        /// 
        /// Defined Values: 1 to 10
        /// 
        /// 
        /// Default Value: 1
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureTriggerNoiseImmunity(bool Trigger_Immunity_Enabled, int Trigger_Immunity_Factor)
        {
            int pInvokeResult = PInvoke.ConfigureTriggerNoiseImmunity(this._handle, System.Convert.ToUInt16(Trigger_Immunity_Enabled), Trigger_Immunity_Factor);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ConfigureTimeSlot
        /// 
        /// ni568x_ConfigureTimeSlot(ViSession vi, ViConstString channelName, ViInt32 slotCount, ViReal64 slotWidth);
        /// 
        /// Purpose
        /// 
        /// Configures the Time Slot mode parameters.
        /// 
        /// This function is only applicable if you have selected NI568X_VAL_TIME_SLOT as the mode parameter in the ni568x_ConfigureAcquisitionMode function.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel you want to configure.
        /// 
        /// 
        /// The only valid value is &quot;0&quot;.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Slot_Count">
        /// 
        /// 
        /// slotCount
        /// ViInt32
        /// Specifies the number of time slots to acquire at a time.
        /// 
        /// 
        /// Valid Range: 2 to 128
        /// 
        /// 
        /// Default Value: 8
        /// 
        /// </param>
        /// <param name="Slot_Width">
        /// 
        /// 
        /// slotWidth
        /// ViReal64
        /// Specifies the width of each time slot, in seconds.
        /// 
        /// 
        /// Valid Range: 0.00001 to 0.100
        /// 
        /// 
        /// Default Value: 0.008
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureTimeSlot(string Channel_Name, int Slot_Count, double Slot_Width)
        {
            int pInvokeResult = PInvoke.ConfigureTimeSlot(this._handle, Channel_Name, Slot_Count, Slot_Width);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ConfigureTimeSlotExclusion
        /// 
        /// ni568x_ConfigureTimeSlotExclusion(ViSession vi, ViConstString channelName, ViBoolean exclusionEnabled, ViReal64 exclusionTimeForSlotStart, ViReal64 exclusionTimeForSlotEnd);
        /// 
        /// Purpose
        /// 
        /// Configures the exclusion period for each time slot. If you enable an exclusion period, a small amount of time at the start and end of each time slot is excluded from the power measurement calculation of each slot.
        /// 
        /// This function is only applicable if you have selected NI568X_VAL_TIME_SLOT as the mode parameter in the ni568x_ConfigureAcquisitionMode function.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel you want to configure.
        /// 
        /// 
        /// The only valid value is &quot;0&quot;.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Exclusion_Enabled">
        /// 
        /// 
        /// exclusionEnabled
        /// ViBoolean
        /// Specifies if the exclusion period is used.
        /// 
        /// 
        /// VI_TRUE (On)
        /// The exclusion period is used.
        /// VI_FALSE (Off)
        /// The exclusion period is not used. This value is the default.
        /// 
        /// 
        /// </param>
        /// <param name="Exclusion_Time_For_Slot_Start">
        /// 
        /// 
        /// exclusionTimeForSlotStart
        /// ViReal64
        /// Specifies the duration of time, in seconds, from the start of each time slot that should not be considered for the power measurement.
        /// 
        /// 
        /// Valid Range: 0 to 0.010
        /// 
        /// 
        /// Default Value: 0.0
        /// 
        /// 
        /// </param>
        /// <param name="Exclusion_Time_For_Slot_End">
        /// 
        /// 
        /// exclusionTimeForSlotEnd
        /// ViReal64
        /// Specifies the duration of time, in seconds, from the end of each time slot that should not be considered for the power measurement.
        /// 
        /// Note??The sum of exclusionTimeForSlotStart and exclusionTimeForSlotEnd must be less than slot width.
        /// 
        /// 
        /// 
        /// Valid Range: 0 to 0.010
        /// 
        /// 
        /// Default Value: 0.0
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureTimeSlotExclusion(string Channel_Name, bool Exclusion_Enabled, double Exclusion_Time_For_Slot_Start, double Exclusion_Time_For_Slot_End)
        {
            int pInvokeResult = PInvoke.ConfigureTimeSlotExclusion(this._handle, Channel_Name, System.Convert.ToUInt16(Exclusion_Enabled), Exclusion_Time_For_Slot_Start, Exclusion_Time_For_Slot_End);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ConfigureScope
        /// 
        /// ni568x_ConfigureScope(ViSession vi, ViConstString channelName, ViReal64 scopeRecordLength, ViInt32 pointsPerRecord);
        /// 
        /// Purpose
        /// 
        /// Configures the length of time for each Scope acquisition mode record and the number of points in each record.
        /// 
        /// This function is only applicable if you have selected NI568X_VAL_SCOPE as the mode parameter in the ni568x_ConfigureAcquisitionMode function.
        /// 
        /// If you want to configure a gate or fence for your Scope acquisition mode application, use the ni568x_ConfigureScopeFence or ni568x_ConfigureScopeGate functions.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel you want to configure.
        /// 
        /// 
        /// The only valid value is &quot;0&quot;.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Scope_Record_Length">
        /// 
        /// 
        /// scopeRecordLength
        /// ViReal64
        /// Specifies the total duration of time, in seconds, of each Scope mode measurement.
        /// 
        /// 
        /// Valid Range: 0.00001 to 0.300
        /// 
        /// 
        /// Default Value: 0.020
        /// 
        /// </param>
        /// <param name="Points_Per_Record">
        /// 
        /// 
        /// pointsPerRecord
        /// ViInt32
        /// Specifies the number of data points within each record.
        /// 
        /// 
        /// Valid Range: 2 to 1,024
        /// 
        /// 
        /// Default Value: 200
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureScope(string Channel_Name, double Scope_Record_Length, int Points_Per_Record)
        {
            int pInvokeResult = PInvoke.ConfigureScope(this._handle, Channel_Name, Scope_Record_Length, Points_Per_Record);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ConfigureScopeGate
        /// 
        /// ni568x_ConfigureScopeGate(ViSession vi, ViConstString channelName, ViBoolean gateEnabled, ViReal64 gateStartTime, ViReal64 gateEndTime);
        /// 
        /// Purpose
        /// 
        /// Configures the Scope mode gate parameters. The gate specifies a portion of the acquired waveform to include in average power measurements. These calculations can be using the Scope Gate Power attributes.
        /// 
        /// The gate only takes effect if you set gateEnabled to TRUE (1).
        /// 
        /// This function is only applicable if you select NI568X_VAL_SCOPE as the mode parameter in the ni568x_ConfigureAcquisitionMode function.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel you want to configure.
        /// 
        /// 
        /// The only valid value is &quot;0&quot;.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Gate_Enabled">
        /// 
        /// 
        /// gateEnabled
        /// ViBoolean
        /// Specifies if the gate region should be used.
        /// 
        ///  
        /// VI_TRUE (On)
        /// Enables the gate.
        /// VI_FALSE (Off)
        /// Disables the gate. This value is the default.
        /// 
        /// 
        /// </param>
        /// <param name="Gate_Start_Time">
        /// 
        /// 
        /// gateStartTime
        /// ViReal64
        /// Specifies the number of seconds from the start of the acquisition at which to start the gate region of the waveform acquisition.
        /// 
        /// 
        /// Valid Range: 0 to 0.300
        /// 
        /// 
        /// Default Value: 0.0
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Gate_End_Time">
        /// 
        /// 
        /// gateEndTime
        /// ViReal64
        /// Specifies the number of seconds from the start of the acquisition at which to end the gate region of the waveform acquisition.
        /// 
        /// 
        /// Valid Range: 0 to 0.300
        /// 
        /// 
        /// Default Value: 0.0
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureScopeGate(string Channel_Name, bool Gate_Enabled, double Gate_Start_Time, double Gate_End_Time)
        {
            int pInvokeResult = PInvoke.ConfigureScopeGate(this._handle, Channel_Name, System.Convert.ToUInt16(Gate_Enabled), Gate_Start_Time, Gate_End_Time);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ConfigureScopeFence
        /// 
        /// ni568x_ConfigureScopeFence(ViSession vi, ViConstString channelName, ViBoolean fenceEnabled, ViReal64 fenceStartTime, ViReal64 fenceEndTime);
        /// 
        /// Purpose
        /// 
        /// Configures the Scope mode fence parameters. The fence is a region within the gate region where the data points are not included in the average gate power calculation. The fence only takes effect if you set fenceEnabled to VI_TURE. The fence region should fall entirely inside the gate region. If the fenceStartTime and fenceEndTime values are the same, the fence is disabled.
        /// 
        /// This function is only applicable if you select NI568X_VAL_SCOPE as the mode parameter in the ni568x_ConfigureAcquisitionMode function.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel you want to configure.
        /// 
        /// 
        /// The only valid value is &quot;0&quot;.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Fence_Enabled">
        /// 
        /// 
        /// fenceEnabled
        /// ViBoolean
        /// Specifies if the fence region should be used.
        /// 
        /// 
        /// VI_TRUE (On)
        /// Enables the fence.
        /// VI_FALSE (Off)
        /// Disables the fence. This value is the default.
        /// 
        /// 
        /// </param>
        /// <param name="Fence_Start_Time">
        /// 
        /// 
        /// fenceStartTime
        /// ViReal64
        /// Specifies the number of seconds from the start of the acquisition at which to start the fence region of the waveform acquisition.
        /// 
        /// 
        /// Valid Range: 0 to 0.300
        /// 
        /// 
        /// Default Value: 0
        /// 
        /// 
        /// </param>
        /// <param name="Fence_End_Time">
        /// 
        /// 
        /// fenceEndTime
        /// ViReal64
        /// Specifies the number of seconds from the start of the acquisition at which to end the fence region of the waveform acquisition.
        /// 
        /// 
        /// Valid Range: 0 to 0.300
        /// 
        /// 
        /// Default Value: 0
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ConfigureScopeFence(string Channel_Name, bool Fence_Enabled, double Fence_Start_Time, double Fence_End_Time)
        {
            int pInvokeResult = PInvoke.ConfigureScopeFence(this._handle, Channel_Name, System.Convert.ToUInt16(Fence_Enabled), Fence_Start_Time, Fence_End_Time);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_Zero
        /// 
        /// ni568x_Zero(ViSession       vi,
        ///     ViConstString   channelName);
        /// 
        /// Purpose
        /// 
        /// Performs a zero correction operation on the specified channel. You can use the  ni568x_IsZeroComplete function to determine when the zero correction is complete.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel on which you want to perform the zero correction. 
        /// 
        /// 
        /// 
        /// 
        /// The only valid value is "0". 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int Zero(string Channel_Name)
        {
            int pInvokeResult = PInvoke.Zero(this._handle, Channel_Name);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ZeroAllChannels
        /// 
        /// ni568x_ZeroAllChannels(ViSession       vi);
        /// 
        /// Purpose
        /// Performs a zero correction operation on all enabled channels. Because the NI&#160;5680/5681 are single-channel devices, zero correction occurs only on one channel. 
        /// 
        /// You can use the  ni568x_IsZeroComplete function to determine when the zero correction is complete.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ZeroAllChannels()
        {
            int pInvokeResult = PInvoke.ZeroAllChannels(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_IsZeroComplete
        /// 
        /// ni568x_IsZeroComplete(
        ///     ViSession       vi,
        ///     ViInt32*        zeroStatus
        /// );
        /// 
        /// Purpose
        /// 
        /// Queries the device to determine whether a zero correction operation initiated by the  ni568x_Zero function is complete, still in progress, or whether the status is unknown.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <param name="Zero_Status">
        /// 
        /// 
        /// zeroStatus
        /// ViInt32*
        /// Returns the status of the zeroing.
        /// 
        /// 
        /// 
        /// NI568X_VAL_ZERO_IN_PROGRESS (0)
        /// The zero correction is still in progress.
        /// NI568X_VAL_ZERO_COMPLETE (1)
        /// A zero correction is complete.
        /// NI568X_VAL_ZERO_STATUS_UNKNOWN (-1)
        /// The NI-568x cannot query the device to determine its state.
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int IsZeroComplete(out int Zero_Status)
        {
            int pInvokeResult = PInvoke.IsZeroComplete(this._handle, out Zero_Status);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_Read
        /// 
        /// ni568x_Read(ViSession       vi,
        ///     ViInt32         maxTimeMillisecond,
        ///     ViReal64*       result);
        /// 
        /// Purpose
        /// 
        /// Initiates a measurement, waits until the measurement is complete and NI-568x returns to the Idle state, and then returns the measurement result in the result parameter. The units of the result are the same as the value of the  NI568X_ATTR_UNITS attribute.
        /// 
        /// If the measured value falls outside the device measurement range, this function returns either an overrange or underrange warning.
        /// 
        /// This function is only applicable if you select NI568X_VAL_CONTINUOUS as the mode in the ni568x_ConfigureAcquisitionMode function.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// 
        /// </summary>
        /// <param name="Max_Time_Millisecond">
        /// 
        /// 
        /// maxTimeMillisecond
        /// ViInt32
        /// Specifies the maximum time in milliseconds to wait for a return value. The default value is 5000. Instead of passing the time in milliseconds, you also can pass one of the following predefined constants:
        /// 
        /// 
        /// 
        /// 
        /// 
        /// NI568X_VAL_MAX_TIME_IMMEDIATE (0)
        /// Immediate timeout.
        /// NI568X_VAL_MAX_TIME_INFINITE (-1)
        /// Infinite timeout.
        /// 
        /// 
        /// 
        /// 
        /// The default value is 5000.
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Result">
        /// 
        /// 
        /// result
        /// ViReal64*
        /// Returns the value measured by the NI-568x device. The result units are the same as the value of the NI568X_ATTR_UNITS attribute.
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int Read(int Max_Time_Millisecond, out double Result)
        {
            int pInvokeResult = PInvoke.Read(this._handle, Max_Time_Millisecond, out Result);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ReadTimeSlotData
        /// 
        /// ni568x_ReadTimeSlotData(ViSession vi, ViConstString channel, ViInt32 slotDataSize, ViInt32 maxTimeMillisecond, ViReal64[] slotData, ViInt32* actualPoints);
        /// 
        /// Purpose
        /// 
        /// Initiates a Time Slot mode acquisition, waits until the acquisition is complete and NI-568x returns to the Idle state, and then returns the acquisition buffer.  The units of the results are the same value of the NI568X_ATTR_UNITS  attribute.
        /// 
        /// This function is only applicable if you select NI568X_VAL_TIME_SLOT as the mode parameter in the ni568x_ConfigureAcquisitionMode function.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel you want to configure.
        /// 
        /// 
        /// The only valid value is &quot;0&quot;.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Slot_Data_Size">
        /// 
        /// 
        /// slotDataSize
        /// ViInt32
        /// Specifies the number of elements in the slotData array available for returning results.
        /// 
        /// </param>
        /// <param name="Max_Time_Millisecond">
        /// 
        /// 
        /// maxTimeMillisecond
        /// ViInt32
        /// Specifies the maximum time in milliseconds to wait for a return value. The default value is 5000. Instead of passing the time in milliseconds, you also can pass one of the following predefined constants:
        /// 
        /// 
        /// 
        /// 
        /// 
        /// NI568X_VAL_MAX_TIME_IMMEDIATE (0)
        /// Immediate timeout.
        /// NI568X_VAL_MAX_TIME_INFINITE (-1)
        /// Infinite timeout.
        /// 
        /// 
        /// 
        /// 
        /// The default value is 5000.
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Slot_Data">
        /// 
        /// 
        /// slotData
        /// ViReal64[]
        /// Returns the Time Slot mode data.
        /// 
        /// </param>
        /// <param name="Actual_Points">
        /// 
        /// 
        /// actualPoints
        /// ViInt32*
        /// The number of items within the slotData array, which is used to return the acquisition.
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ReadTimeSlotData(string Channel_Name, int Slot_Data_Size, int Max_Time_Millisecond, double[] Slot_Data, out int Actual_Points)
        {
            int pInvokeResult = PInvoke.ReadTimeSlotData(this._handle, Channel_Name, Slot_Data_Size, Max_Time_Millisecond, Slot_Data, out Actual_Points);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ReadScopeData
        /// 
        /// ni568x_ReadScopeData(ViSession vi, ViConstString channelName, ViInt32 recordBufferSize, ViInt32 maxTimeMillisecond, ViReal64[] recordBuffer, ViInt32* actualPoints);
        /// 
        /// Purpose
        /// 
        /// Initiates a Scope mode acquisition, waits until the acquisition is complete and NI-568x returns to the Idle state, and then returns the acquisition buffer.  The units of the results are the same value of the NI568X_ATTR_UNITS  attribute.
        /// 
        /// This function is only applicable if you select NI568X_VAL_SCOPE as the mode parameter in the ni568x_ConfigureAcquisitionMode function.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel you want to configure.
        /// 
        /// 
        /// The only valid value is &quot;0&quot;.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Record_Buffer_Size">
        /// 
        /// 
        /// recordBufferSize
        /// ViInt32
        /// Specifies the number of elements in the recordBuffer  array available for returning results.
        /// 
        /// </param>
        /// <param name="Max_Time_Millisecond">
        /// 
        /// 
        /// maxTimeMillisecond
        /// ViInt32
        /// Specifies the maximum time in milliseconds to wait for a return value. The default value is 5000. Instead of passing the time in milliseconds, you also can pass one of the following predefined constants:
        /// 
        /// 
        /// 
        /// 
        /// 
        /// NI568X_VAL_MAX_TIME_IMMEDIATE (0)
        /// Immediate timeout.
        /// NI568X_VAL_MAX_TIME_INFINITE (-1)
        /// Infinite timeout.
        /// 
        /// 
        /// 
        /// 
        /// The default value is 5000.
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Record_Buffer">
        /// 
        /// 
        /// recordBuffer
        /// ViReal64[]
        /// Returns the buffer in which the results of the acquisition are contained. The size of the buffer is specified by the ni568x_ConfigureScope function. 
        /// 
        /// 
        /// </param>
        /// <param name="Actual_Points">
        /// 
        /// 
        /// actualPoints
        /// ViInt32*
        /// The number of items within the slotData array, which is used to return the acquisition.
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ReadScopeData(string Channel_Name, int Record_Buffer_Size, int Max_Time_Millisecond, double[] Record_Buffer, out int Actual_Points)
        {
            int pInvokeResult = PInvoke.ReadScopeData(this._handle, Channel_Name, Record_Buffer_Size, Max_Time_Millisecond, Record_Buffer, out Actual_Points);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_Initiate
        /// 
        /// ni568x_Initiate(ViSession       vi);
        /// 
        /// Purpose
        /// 
        /// Initiates a measurement. NI-568x leaves the Idle state when this function executes. Use the ni568x_IsMeasurementComplete function to check whether the measurement is complete. Use the ni568x_Fetch function to retrieve the measurement data.
        /// 
        /// This function does not check the device status. Typically, you call this function only in a sequence of calls to other low-level functions. The sequence performs one operation. Use the low-level functions to optimize one or more aspects of interaction with NI-568x. To check the device status, call the ni568x_error_query function at the conclusion of the sequence.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int Initiate()
        {
            int pInvokeResult = PInvoke.Initiate(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_IsMeasurementComplete
        /// 
        /// ni568x_IsMeasurementComplete(ViSession       vi,
        ///     ViInt32*        measurementStatus);
        /// 
        /// Purpose
        /// 
        /// Queries the device to determine whether measurements are complete, still in progress, or whether the measurement status is unknown.
        /// 
        /// This function does not check the device status. Typically, you call this function only in a sequence of calls to other low-level functions. The sequence performs one operation. Use the low-level functions to optimize one or more aspects of interaction with NI-568x. To check the device status, call the ni568x_error_query function at the conclusion of the sequence.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// 
        /// </summary>
        /// <param name="Measurement_Status">
        /// 
        /// 
        /// 
        /// measurementStatus
        /// ViInt32*
        /// Returns the status of the measurement.
        /// 
        /// 
        /// 
        /// 
        /// The valid values follow:
        /// 
        /// 
        /// 
        /// 
        /// 
        /// NI568X_VAL_MEAS_COMPLETE (1)
        /// Measurement complete.
        /// NI568X_VAL_MEAS_STATUS_UNKNOWN (-1)
        /// Measurement status unknown.
        /// NI568X_VAL_MEAS_IN_PROGRESS (0)
        /// Measurement in progress.
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int IsMeasurementComplete(out int Measurement_Status)
        {
            int pInvokeResult = PInvoke.IsMeasurementComplete(this._handle, out Measurement_Status);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_Fetch
        /// 
        /// ni568x_Fetch(ViSession       vi,
        ///     ViReal64*       reading);
        /// 
        /// Purpose
        /// 
        /// Returns the result from a previously initiated measurement. Call the ni568x_Initiate function to initiate a measurement before calling this function. After the ni568x_Fetch function executes, the reading parameter contains an actual reading on the channel. The reading units are those specified by the NI568X_ATTR_UNITS attribute.
        /// 
        /// If the measured value falls outside the specified range, this function returns either an overrange or underrange warning.
        /// 
        /// The ni568x_Fetch function does not check the device status. Typically, you call this function only in a sequence of calls to other low-level functions. The sequence performs one operation. Use low-level functions to optimize one or more aspects of interaction with the NI-568x device. To check the device status, call the ni568x_error_query function at the conclusion of the sequence.
        /// 
        /// This function is only applicable if you select NI568X_VAL_CONTINUOUS as the mode parameter in the ni568x_ConfigureAcquisitionMode function.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <param name="Reading">
        /// 
        /// 
        /// reading
        /// ViReal64*
        /// Returns the value measured by the NI-568x device. The result units are specified with the NI568X_ATTR_UNITS attribute.
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int Fetch(out double Reading)
        {
            int pInvokeResult = PInvoke.Fetch(this._handle, out Reading);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_QueryResultRangeType
        /// 
        /// ni568x_QueryResultRangeType(ViSession       vi,
        ///     ViReal64        measurementValue,
        ///     ViInt32*        rangeType);
        /// 
        /// Purpose
        /// 
        /// Takes a measurement value from either the ni568x_Fetch function or the ni568x_Read function and determines whether the value is valid. If the value is not valid, this function indicates that an out-of-range condition occurred.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <param name="Measurement_Value">
        /// 
        /// 
        /// measurementValue
        /// ViReal64
        /// Displays the measurement value returned by either the ni568x_Fetch function or the ni568x_Read function.
        /// 
        /// 
        /// </param>
        /// <param name="Range_Type">
        /// 
        /// 
        /// rangeType
        /// ViInt32*
        /// Returns whether the value displayed in measurementValue is a valid measurement or if the value indicates that NI-568x encountered an out-of-range condition.
        /// 
        /// 
        /// 
        /// 
        /// 
        /// NI568X_VAL_IN_RANGE (0)
        /// Measurement in range
        /// NI568X_VAL_UNDER_RANGE (-1)
        /// Measurement under range
        /// NI568X_VAL_OVER_RANGE (1)
        /// Measurement over range
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int QueryResultRangeType(double Measurement_Value, out int Range_Type)
        {
            int pInvokeResult = PInvoke.QueryResultRangeType(this._handle, Measurement_Value, out Range_Type);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_Abort
        /// 
        /// ni568x_Abort(ViSession       vi);
        /// 
        /// Purpose
        /// 
        /// Aborts all previously initiated measurements and returns the NI-568x device to the Idle state.
        /// 
        /// 
        /// This function does not check the device status. Typically, you call this function only in a sequence of calls to other low-level functions. The sequence performs one operation. Use the low-level functions to optimize one or more aspects of interaction between you and the NI-568x device. To check the device status, call the ni568x_error_query function at the conclusion of the sequence.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int Abort()
        {
            int pInvokeResult = PInvoke.Abort(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_SendSoftwareTrigger
        /// 
        /// ni568x_SendSoftwareTrigger(ViSession       vi);
        /// 
        /// Purpose
        /// 
        /// Sends a software trigger to the device. To use the software trigger, first call the ni568x_ConfigureTriggerSource function, and select NI568X_VAL_SOFTWARE as the value of the triggerSource parameter.
        /// 
        /// This function returns an error if you configure an invalid trigger or you have not previously called the ni568x_Initiate function. 
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int SendSoftwareTrigger()
        {
            int pInvokeResult = PInvoke.SendSoftwareTrigger(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_FetchTimeSlotData
        /// 
        /// ni568x_FetchSlotData(ViSession vi, ViConstString channelName, ViInt32 slotDataSize, ViReal64[] slotData, ViInt32* actualPoints);
        /// 
        /// Purpose
        /// 
        /// 
        /// Returns the acquisition buffer from a previously initiated Time Slot mode acquisition.
        /// 
        /// This function is only applicable if you have selected NI568X_VAL_TIME_SLOT as the mode parameter in the ni568x_ConfigureAcquisitionMode function.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel you want to configure.
        /// 
        /// 
        /// The only valid value is &quot;0&quot;.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Slot_Data_Size">
        /// 
        /// 
        /// slotDataSize
        /// ViReal64[]
        /// Specifies the offset from the start of each scope record that should be used for gate calculations.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Buffer_Data">
        /// 
        /// 
        /// bufferData
        /// ViReal64[]
        /// The buffer in which the results of the acquisition are returned.
        /// 
        /// </param>
        /// <param name="Actual_Points">
        /// 
        /// 
        /// actualPoints
        /// ViInt32*
        /// The number of items within the slotData array, which is used to return the acquisition.
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int FetchTimeSlotData(string Channel_Name, int Slot_Data_Size, double[] Buffer_Data, out int Actual_Points)
        {
            int pInvokeResult = PInvoke.FetchTimeSlotData(this._handle, Channel_Name, Slot_Data_Size, Buffer_Data, out Actual_Points);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_FetchScopeData
        /// 
        /// ni568x_FetchScopeData(ViSession vi, ViConstString channelName, ViInt32 recordBufferSize, ViReal64[] recordBuffer, ViInt32* actualPoints);
        /// 
        /// Purpose
        /// 
        /// Returns the buffer from a previously initiated Scope mode acquisition.
        /// 
        /// This function is only applicable if you have selected NI568X_VAL_SCOPE as the mode parameter in the ni568x_ConfigureAcquisitionMode function.
        /// 
        /// Supported Devices: NI 5681
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel you want to configure.
        /// 
        /// 
        /// The only valid value is &quot;0&quot;.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Record_Buffer_Size">
        /// 
        /// 
        /// recordBufferSize
        /// ViInt32
        /// Specifies the number of elements in the recordBuffer array.
        /// 
        /// 
        /// </param>
        /// <param name="Record_Buffer">
        /// 
        /// 
        /// recordBuffer
        /// ViReal64
        /// Returns the buffer in which the results of the acquisition are contained.
        /// 
        /// </param>
        /// <param name="Actual_Data_Points">
        /// 
        /// 
        /// actualDataPoints
        /// ViInt32*
        /// Returns the number of elements within the recordBuffer array that are used to return the acquisition.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int FetchScopeData(string Channel_Name, int Record_Buffer_Size, double[] Record_Buffer, out int Actual_Data_Points)
        {
            int pInvokeResult = PInvoke.FetchScopeData(this._handle, Channel_Name, Record_Buffer_Size, Record_Buffer, out Actual_Data_Points);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_reset
        /// 
        /// ni568x_reset(ViSession       vi);
        /// 
        /// Purpose
        /// 
        /// Resets the device to a known state and sends initialization commands.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int reset()
        {
            int pInvokeResult = PInvoke.reset(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ResetWithDefaults
        /// 
        /// ni568x_ResetWithDefaults(ViSession       vi);
        /// 
        /// Purpose
        /// 
        /// Resets the device and applies initial user-specified settings from the logical name used to initialize the session. If the session was created without a logical name, this function is equivalent to the ni568x_reset function.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ResetWithDefaults()
        {
            int pInvokeResult = PInvoke.ResetWithDefaults(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_Disable
        /// 
        /// ni568x_Disable(ViSession       vi);
        /// 
        /// Purpose
        /// 
        /// Places the device in a quiescent state in which it has minimal or no impact on the system to which it is connected. If a measurement is in progress when you call this function, the measurement is aborted.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int Disable()
        {
            int pInvokeResult = PInvoke.Disable(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_self_test
        /// 
        /// ni568x_self_test(ViSession       vi,
        ///     ViInt16*       selfTestResult,
        ///     ViChar[]       selfTestMessage);
        /// 
        /// Purpose
        /// 
        /// Performs a self-test on the NI-568x device and returns the test result(s).
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <param name="Self_Test_Result">
        /// 
        /// 
        /// selfTestResult
        /// ViInt16*
        /// Returns the value returned from the instrument self test.
        /// 
        /// 
        /// 
        ///                                                 Self-Test Result
        ///                     Description
        ///                 
        ///                                     0
        ///                     Passed self test.
        ///                 
        ///                                     1
        ///                     Failed self test.
        ///                 
        ///             
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Self_Test_Message">
        /// 
        /// 
        /// selfTestMessage
        /// ViChar[]
        /// Returns the self-test response string from the device.
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int self_test(out short Self_Test_Result, System.Text.StringBuilder Self_Test_Message)
        {
            int pInvokeResult = PInvoke.self_test(this._handle, out Self_Test_Result, Self_Test_Message);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_revision_query
        /// 
        /// ni568x_revision_query(ViSession       vi,
        ///     ViChar[]          instrumentDriverRevision,
        ///     ViChar[]          firmwareRevision);
        /// 
        /// Purpose
        /// 
        /// Returns the revision numbers of the NI-568x instrument driver and device firmware.
        /// 
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// 
        /// 
        /// </summary>
        /// <param name="Instrument_Driver_Revision">
        /// 
        /// 
        /// instrumentDriverRevision
        /// ViChar[]
        /// Returns the revision numbers of the NI-568x instrument driver in the form of a string.
        /// 
        /// 
        /// 
        /// 
        /// 
        /// You must pass a ViChar array with at least 256 bytes.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Firmware_Revision">
        /// 
        /// 
        /// firmwareRevision
        /// ViChar[]
        /// Returns the device firmware revision numbers in the form of a string.
        /// 
        /// 
        /// 
        /// 
        /// 
        /// You must pass a ViChar array with at least 256 bytes.
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int revision_query(System.Text.StringBuilder Instrument_Driver_Revision, System.Text.StringBuilder Firmware_Revision)
        {
            int pInvokeResult = PInvoke.revision_query(this._handle, Instrument_Driver_Revision, Firmware_Revision);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_error_query
        /// 
        /// ni568x_error_query(ViSession       vi,
        ///     ViInt32*        errorCode,
        ///     ViChar[]        errorMessage);
        /// 
        /// Purpose
        /// 
        /// Reads and returns an error code and an error message from the NI-568x error queue.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <param name="Error_Code">
        /// 
        /// 
        /// errorCode
        /// ViInt32*
        /// Returns the error code read from the NI-568x device.
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Error_Message">
        /// 
        /// 
        /// 
        /// errorMessage
        /// ViChar[]
        /// Returns the error message string that corresponds to the status code specified by errorCode.
        /// 
        /// 
        /// 
        /// 
        /// 
        /// You must pass a ViChar array of at least 256 bytes.
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int error_query(out int Error_Code, System.Text.StringBuilder Error_Message)
        {
            int pInvokeResult = PInvoke.error_query(this._handle, out Error_Code, Error_Message);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_InvalidateAllAttributes
        /// 
        /// ni568x_InvalidateAllAttributes(ViSession       vi);
        /// 
        /// Purpose
        /// 
        /// Invalidates the cached values of all attributes for the device session.
        /// 
        /// Supported Devices: NI 5680/5681
        /// </summary>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int InvalidateAllAttributes()
        {
            int pInvokeResult = PInvoke.InvalidateAllAttributes(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_GetNextCoercionRecord
        /// 
        /// ni568x_GetNextCoercionRecord(ViSession       vi,
        ///     ViInt32         bufferSize,
        ///     ViChar[]        record);
        /// 
        /// Purpose
        /// 
        /// Returns the coercion information associated with the IVI session. This function retrieves and clears the oldest instance in which NI-568x coerced a user-specified value to another value.
        /// 
        /// If you set the NI568X_ATTR_RECORD_COERCIONS attribute to VI_TRUE, NI-568x keeps a list of all coercions it makes on ViInt32 or ViReal64 values you pass to NI-568x functions. Use this function to retrieve information from that list.
        /// 
        /// Call this function until no coercion records remain for the session. This function returns an empty string in coercionRecord if no coercion records remain for the session.
        /// 
        /// If the next coercion record string, including the terminating NULL byte, contains more bytes than you indicate in this parameter, the function copies bufferSize - 1 bytes into the buffer, places an ASCII NULL byte at the end of the buffer, and returns the size of the buffer that you must pass to get the entire value. For example, if the value is "123456" and the bufferSize is 4, the function places "123" into the buffer and returns 7.
        /// 
        /// If you pass a negative number to bufferSize, the function copies the value to the buffer regardless of the number of bytes in the value.
        /// 
        /// If you pass 0 to bufferSize, you can pass VI_NULL for the coercionRecord buffer parameter.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <param name="Buffer_Size">
        /// 
        /// 
        /// bufferSize
        /// ViInt32
        /// Indicates the number of bytes in the ViChar array that you specify for attributeValue.  
        /// 
        /// If the current value of the attribute, including the terminating NULL byte, is larger than the size you indicate in bufferSize, the function copies bufferSize - 1 bytes into the buffer, places an ASCII NULL byte at the end of the buffer, and returns the size of the buffer that you must pass to get the entire value. For example, if the value is "123456" and the bufferSize is 4, the function places "123" into the buffer and returns 7.
        /// 
        /// 
        /// 
        /// 
        /// If you pass a negative number to this parameter, the function copies the value to the buffer regardless of the number of bytes in the value.
        /// 
        /// 
        /// 
        /// 
        /// If you pass 0 to this parameter, you can pass VI_NULL for the attributeValue buffer parameter.
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Coercion_Record">
        /// 
        /// 
        /// record
        /// ViChar[]
        /// Returns the next coercion record for the IVI session. If there are no coercion records, the function returns an empty string.
        /// 
        /// 
        /// 
        /// 
        /// The buffer must contain at least as many elements as the value you specify with bufferSize. If the next coercion record string, including the terminating NULL byte, contains more bytes than you indicate with bufferSize, the function copies bufferSize - 1 bytes into the buffer, places an ASCII NULL byte at the end of the buffer, and returns the size of the buffer you must pass to get the entire value. For example, if the value is "123456" and the bufferSize is 4, the function places "123" into the buffer and returns 7.
        /// 
        /// 
        /// 
        /// 
        /// This parameter returns an empty string if no coercion records remain for the session.
        ///  
        /// </param>
        /// <returns>
        /// 
        /// 
        /// statusOrRequiredSize
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// 
        /// If the current value of the attribute, including the terminating NULL byte, is larger than the size you indicate in bufferSize, the function copies bufferSize - 1 bytes into the buffer, places an ASCII NULL byte at the end of the buffer, and returns the size of the buffer that you must pass to get the entire value. For example, if the value is "123456" and the bufferSize is 4, the function places "123" into the buffer and returns 7.
        /// 
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.          
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int GetNextCoercionRecord(int Buffer_Size, System.Text.StringBuilder Coercion_Record)
        {
            int pInvokeResult = PInvoke.GetNextCoercionRecord(this._handle, Buffer_Size, Coercion_Record);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_GetNextInterchangeWarning
        /// 
        /// ni568x_GetNextInterchangeWarning(ViSession       vi,
        ///     ViInt32         bufferSize,
        ///     ViChar[]        interchangeWarning);
        /// 
        /// Purpose
        /// 
        /// Returns the interchangeability warnings associated with the IVI session. 
        /// 
        /// NI-568x generates interchangeability warnings when an attribute that affects the device behavior is in a state that you did not specify. Interchangeability warnings indicate that using your application with a different device might cause different behavior. This function retrieves and clears the oldest instance in which NI-568x recorded an interchangeability warning. 
        /// 
        /// NI-568x performs interchangeability-checking when the NI568X_ATTR_INTERCHANGE_CHECK attribute is set to VI_TRUE.
        /// 
        /// This function returns an empty string in interchangeWarning if no interchangeability warnings remain for the session.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <param name="Buffer_Size">
        /// 
        /// 
        /// bufferSize
        /// ViInt32
        /// Indicates the number of bytes in the ViChar array that you specify for attributeValue.  
        /// 
        /// If the current value of the attribute, including the terminating NULL byte, is larger than the size you indicate in bufferSize, the function copies bufferSize - 1 bytes into the buffer, places an ASCII NULL byte at the end of the buffer, and returns the size of the buffer that you must pass to get the entire value. For example, if the value is "123456" and the bufferSize is 4, the function places "123" into the buffer and returns 7.
        /// 
        /// 
        /// 
        /// 
        /// If you pass a negative number to this parameter, the function copies the value to the buffer regardless of the number of bytes in the value.
        /// 
        /// 
        /// 
        /// 
        /// If you pass 0 to this parameter, you can pass VI_NULL for the attributeValue buffer parameter.
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Interchange_Warning">
        /// 
        /// 
        /// interchangeWarning
        /// ViChar[]
        /// Returns the oldest interchange warning for the IVI session. This parameter returns an empty string if there are no interchange warnings remaining for the session.
        /// 
        /// 
        /// 
        /// 
        /// 
        /// The buffer must contain at least as many elements as the value you specify with bufferSize. If the next interchangeability warning string, including the terminating NULL byte, contains more bytes than you indicate with bufferSize, the function copies bufferSize - 1 bytes into the buffer, places an ASCII NULL byte at the end of the buffer, and returns the size of the buffer that you must pass to get the entire value. For example, if the value is "123456" and the bufferSize is 4, the function places "123" into the buffer and returns 7.
        /// 
        ///  
        /// 
        /// </param>
        /// <returns>
        /// 
        /// 
        /// statusOrRequiredSize
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// 
        /// If the current value of the attribute, including the terminating NULL byte, is larger than the size you indicate in bufferSize, the function copies bufferSize - 1 bytes into the buffer, places an ASCII NULL byte at the end of the buffer, and returns the size of the buffer that you must pass to get the entire value. For example, if the value is "123456" and the bufferSize is 4, the function places "123" into the buffer and returns 7.
        /// 
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.          
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int GetNextInterchangeWarning(int Buffer_Size, System.Text.StringBuilder Interchange_Warning)
        {
            int pInvokeResult = PInvoke.GetNextInterchangeWarning(this._handle, Buffer_Size, Interchange_Warning);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ClearInterchangeWarnings
        /// 
        /// ni568x_ClearInterchangeWarnings(ViSession       vi);
        /// 
        /// Purpose
        /// 
        /// Clears the list of recorded interchange warnings. Interchange warnings indicate that using your application with a different device might cause different behavior.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ClearInterchangeWarnings()
        {
            int pInvokeResult = PInvoke.ClearInterchangeWarnings(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// ni568x_ResetInterchangeCheck
        /// 
        /// ni568x_ResetInterchangeCheck(ViSession       vi);
        /// 
        /// Purpose
        /// 
        /// Begins a new series of interchange checks.
        /// 
        /// When developing a complex test system that consists of multiple test modules, NI recommends designing the test modules to run in any order. Doing so requires that each test module completely configure the state of each device it uses. If a particular test module does not completely configure the state of a device, the state of the device depends on the configuration from a previously executed test module.
        /// 
        /// If you execute the test modules in a different order, the behavior of the device, and therefore the entire test module, is likely to change. This behavior change is generally device specific and represents an interchangeability problem. You can use the ni568x_ResetInterchangeCheck function to test for such cases. After you call this function, the interchangeability-checking algorithms in NI-568x ignore all previous configuration operations. Call this function at the beginning of a test module to determine whether the test module depends on the operation of previously executed test modules.
        /// 
        /// This function does not clear the interchangeability warnings from the list of previously recorded interchangeability warnings. If you want to guarantee that the ni568x_GetNextInterchangeWarning function only returns those interchangeability warnings that are generated after calling the ni568x_ResetInterchangeCheck function, clear the list of interchangeability warnings by repeatedly calling the ni568x_GetNextInterchangeWarning function until no more interchangeability warnings are returned. If you are not interested in the content of those warnings, call the ni568x_ClearInterchangeWarnings function.
        /// 
        /// Supported Devices: NI 5680/5681
        /// 
        /// 
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// 
        /// Status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-568x function to determine whether an error has occurred.
        /// 
        /// 
        /// 
        /// To obtain a text description of the status code, call the ni568x_error_message function. To obtain additional information about the error condition, call the ni568x_GetError function. To clear the error information from NI-568x, call the ni568x_ClearError function.
        /// 
        /// 
        ///           
        /// The general meaning of the status code is as follows:
        /// 
        /// 
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// </returns>
        public int ResetInterchangeCheck()
        {
            int pInvokeResult = PInvoke.ResetInterchangeCheck(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }
        /// <summary>
        /// 
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
            System.GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if ((this._disposed == false))
            {
                PInvoke.close(this._handle);
                this._handle = new System.Runtime.InteropServices.HandleRef(null, System.IntPtr.Zero);
            }
            this._disposed = true;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <returns></returns>
        public int GetInt32(ni568xProperties propertyId, string repeatedCapabilityOrChannel)
        {
            int val;
            PInvoke.TestForError(this._handle, PInvoke.GetAttributeViInt32(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), out val));
            return val;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <returns></returns>
        public int GetInt32(ni568xProperties propertyId)
        {
            return this.GetInt32(propertyId, "");
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <returns></returns>
        public double GetDouble(ni568xProperties propertyId, string repeatedCapabilityOrChannel)
        {
            double val;
            PInvoke.TestForError(this._handle, PInvoke.GetAttributeViReal64(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), out val));
            return val;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <returns></returns>
        public double GetDouble(ni568xProperties propertyId)
        {
            return this.GetDouble(propertyId, "");
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <returns></returns>
        public string GetString(ni568xProperties propertyId, string repeatedCapabilityOrChannel)
        {
            System.Text.StringBuilder newVal = new System.Text.StringBuilder(512);
            int size = PInvoke.GetAttributeViString(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), 512, newVal);
            if ((size < 0))
            {
                PInvoke.ThrowError(this._handle, size);
            }
            else
            {
                if ((size > 0))
                {
                    newVal.Capacity = size;
                    PInvoke.TestForError(this._handle, PInvoke.GetAttributeViString(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), size, newVal));
                }
            }
            return newVal.ToString();
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <returns></returns>
        public string GetString(ni568xProperties propertyId)
        {
            return this.GetString(propertyId, "");
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <returns></returns>
        public bool GetBoolean(ni568xProperties propertyId, string repeatedCapabilityOrChannel)
        {
            ushort val;
            PInvoke.TestForError(this._handle, PInvoke.GetAttributeViBoolean(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), out val));
            return System.Convert.ToBoolean(val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <returns></returns>
        public bool GetBoolean(ni568xProperties propertyId)
        {
            return this.GetBoolean(propertyId, "");
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        public void SetInt32(ni568xProperties propertyId, string repeatedCapabilityOrChannel, int val)
        {
            PInvoke.TestForError(this._handle, PInvoke.SetAttributeViInt32(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        public void SetInt32(ni568xProperties propertyId, int val)
        {
            this.SetInt32(propertyId, "", val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        public void SetDouble(ni568xProperties propertyId, string repeatedCapabilityOrChannel, double val)
        {
            PInvoke.TestForError(this._handle, PInvoke.SetAttributeViReal64(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        public void SetDouble(ni568xProperties propertyId, double val)
        {
            this.SetDouble(propertyId, "", val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        public void SetString(ni568xProperties propertyId, string repeatedCapabilityOrChannel, string val)
        {
            PInvoke.TestForError(this._handle, PInvoke.SetAttributeViString(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        public void SetString(ni568xProperties propertyId, string val)
        {
            this.SetString(propertyId, "", val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        public void SetBoolean(ni568xProperties propertyId, string repeatedCapabilityOrChannel, bool val)
        {
            PInvoke.TestForError(this._handle, PInvoke.SetAttributeViBoolean(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), System.Convert.ToUInt16(val)));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        public void SetBoolean(ni568xProperties propertyId, bool val)
        {
            this.SetBoolean(propertyId, "", val);
        }

        // Added in 15.0

        /// <summary>
        /// 
        /// </summary>
        /// <param name="Trigger_Hysteresis_Enabled"></param>
        /// <param name="Trigger_Hysteresis"></param>
        /// <returns></returns>
        public int ConfigureTriggerHysteresis(bool Trigger_Hysteresis_Enabled, double Trigger_Hysteresis)
        {
            int pInvokeResult = PInvoke.ConfigureTriggerHysteresis(this._handle, System.Convert.ToUInt16(Trigger_Hysteresis_Enabled), Trigger_Hysteresis);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="Buffer_Size"></param>
        /// <param name="Max_Time_Millisecond"></param>
        /// <param name="Power"></param>
        /// <returns></returns>
        public int ReadArray(out int Buffer_Size, int Max_Time_Millisecond, out double Power)
        {
            int pInvokeResult = PInvoke.ReadArray(this._handle, out Buffer_Size, Max_Time_Millisecond, out Power);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="Buffer_Size"></param>
        /// <param name="Power"></param>
        /// <returns></returns>
        public int FetchArray(out int Buffer_Size, out double Power)
        {
            int pInvokeResult = PInvoke.FetchArray(this._handle, out Buffer_Size, out Power);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        private class PInvoke
        {
            private const string nativeDllName32 = "ni568x.dll";
            private const string nativeDllName64 = "ni568x_64.dll";

            // Define the readonly field to check for process' bitness.
            private static readonly bool Is64BitProcess = (IntPtr.Size == 8);

            [DllImport(nativeDllName32, EntryPoint = "ni568x_init", CallingConvention = CallingConvention.StdCall)]
            public static extern int init_32(string Resource_Name, ushort ID_Query, ushort Reset_Device, out System.IntPtr Instrument_Handle);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_init", CallingConvention = CallingConvention.StdCall)]
            public static extern int init_64(string Resource_Name, ushort ID_Query, ushort Reset_Device, out System.IntPtr Instrument_Handle);
            public static int init(string Resource_Name, ushort ID_Query, ushort Reset_Device, out System.IntPtr Instrument_Handle)
            {
                if (Is64BitProcess)
                    return init_64(Resource_Name, ID_Query, Reset_Device, out  Instrument_Handle);
                else
                    return init_32(Resource_Name, ID_Query, Reset_Device, out  Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_InitWithOptions", CallingConvention = CallingConvention.StdCall)]
            public static extern int InitWithOptions_32(string Resource_Name, ushort ID_Query, ushort Reset_Device, string Option_String, out System.IntPtr Instrument_Handle);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_InitWithOptions", CallingConvention = CallingConvention.StdCall)]
            public static extern int InitWithOptions_64(string Resource_Name, ushort ID_Query, ushort Reset_Device, string Option_String, out System.IntPtr Instrument_Handle);
            public static int InitWithOptions(string Resource_Name, ushort ID_Query, ushort Reset_Device, string Option_String, out System.IntPtr Instrument_Handle)
            {
                if (Is64BitProcess)
                    return InitWithOptions_64(Resource_Name, ID_Query, Reset_Device, Option_String, out  Instrument_Handle);
                else
                    return InitWithOptions_32(Resource_Name, ID_Query, Reset_Device, Option_String, out  Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureAcquisitionMode", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureAcquisitionMode_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Mode);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureAcquisitionMode", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureAcquisitionMode_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Mode);
            public static int ConfigureAcquisitionMode(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Mode)
            {
                if (Is64BitProcess)
                    return ConfigureAcquisitionMode_64(Instrument_Handle, Channel_Name, Mode);
                else
                    return ConfigureAcquisitionMode_32(Instrument_Handle, Channel_Name, Mode);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureUnits", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureUnits_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Units);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureUnits", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureUnits_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Units);
            public static int ConfigureUnits(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Units)
            {
                if (Is64BitProcess)
                    return ConfigureUnits_64(Instrument_Handle, Units);
                else
                    return ConfigureUnits_32(Instrument_Handle, Units);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureMeasurement", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureMeasurement_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Math_Operator, string Channel_Name_One, string Channel_Name_Two);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureMeasurement", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureMeasurement_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Math_Operator, string Channel_Name_One, string Channel_Name_Two);
            public static int ConfigureMeasurement(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Math_Operator, string Channel_Name_One, string Channel_Name_Two)
            {
                if (Is64BitProcess)
                    return ConfigureMeasurement_64(Instrument_Handle, Math_Operator, Channel_Name_One, Channel_Name_Two);
                else
                    return ConfigureMeasurement_32(Instrument_Handle, Math_Operator, Channel_Name_One, Channel_Name_Two);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureRangeAutoEnabled", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureRangeAutoEnabled_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, ushort Range_Auto_Enabled);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureRangeAutoEnabled", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureRangeAutoEnabled_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, ushort Range_Auto_Enabled);
            public static int ConfigureRangeAutoEnabled(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, ushort Range_Auto_Enabled)
            {
                if (Is64BitProcess)
                    return ConfigureRangeAutoEnabled_64(Instrument_Handle, Channel_Name, Range_Auto_Enabled);
                else
                    return ConfigureRangeAutoEnabled_32(Instrument_Handle, Channel_Name, Range_Auto_Enabled);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureAveragingAutoEnabled", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureAveragingAutoEnabled_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, ushort Averaging_Auto_Enabled);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureAveragingAutoEnabled", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureAveragingAutoEnabled_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, ushort Averaging_Auto_Enabled);
            public static int ConfigureAveragingAutoEnabled(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, ushort Averaging_Auto_Enabled)
            {
                if (Is64BitProcess)
                    return ConfigureAveragingAutoEnabled_64(Instrument_Handle, Channel_Name, Averaging_Auto_Enabled);
                else
                    return ConfigureAveragingAutoEnabled_32(Instrument_Handle, Channel_Name, Averaging_Auto_Enabled);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureCorrectionFrequency", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureCorrectionFrequency_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, double Frequency);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureCorrectionFrequency", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureCorrectionFrequency_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, double Frequency);
            public static int ConfigureCorrectionFrequency(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, double Frequency)
            {
                if (Is64BitProcess)
                    return ConfigureCorrectionFrequency_64(Instrument_Handle, Channel_Name, Frequency);
                else
                    return ConfigureCorrectionFrequency_32(Instrument_Handle, Channel_Name, Frequency);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureOffset", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureOffset_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, double Offset);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureOffset", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureOffset_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, double Offset);
            public static int ConfigureOffset(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, double Offset)
            {
                if (Is64BitProcess)
                    return ConfigureOffset_64(Instrument_Handle, Channel_Name, Offset);
                else
                    return ConfigureOffset_32(Instrument_Handle, Channel_Name, Offset);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureRange", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureRange_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, double Range_Lower, double Range_Upper);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureRange", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureRange_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, double Range_Lower, double Range_Upper);
            public static int ConfigureRange(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, double Range_Lower, double Range_Upper)
            {
                if (Is64BitProcess)
                    return ConfigureRange_64(Instrument_Handle, Channel_Name, Range_Lower, Range_Upper);
                else
                    return ConfigureRange_32(Instrument_Handle, Channel_Name, Range_Lower, Range_Upper);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureAveragingCount", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureAveragingCount_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Averaging_Count);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureAveragingCount", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureAveragingCount_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Averaging_Count);
            public static int ConfigureAveragingCount(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Averaging_Count)
            {
                if (Is64BitProcess)
                    return ConfigureAveragingCount_64(Instrument_Handle, Channel_Name, Averaging_Count);
                else
                    return ConfigureAveragingCount_32(Instrument_Handle, Channel_Name, Averaging_Count);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureDutyCycleCorrection", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureDutyCycleCorrection_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, ushort Correction_Enabled, double Correction);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureDutyCycleCorrection", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureDutyCycleCorrection_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, ushort Correction_Enabled, double Correction);
            public static int ConfigureDutyCycleCorrection(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, ushort Correction_Enabled, double Correction)
            {
                if (Is64BitProcess)
                    return ConfigureDutyCycleCorrection_64(Instrument_Handle, Channel_Name, Correction_Enabled, Correction);
                else
                    return ConfigureDutyCycleCorrection_32(Instrument_Handle, Channel_Name, Correction_Enabled, Correction);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_GetChannelName", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetChannelName_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Index, int Buffer_Size, System.Text.StringBuilder Name);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_GetChannelName", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetChannelName_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Index, int Buffer_Size, System.Text.StringBuilder Name);
            public static int GetChannelName(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Index, int Buffer_Size, System.Text.StringBuilder Name)
            {
                if (Is64BitProcess)
                    return GetChannelName_64(Instrument_Handle, Index, Buffer_Size, Name);
                else
                    return GetChannelName_32(Instrument_Handle, Index, Buffer_Size, Name);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureTriggerSource", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureTriggerSource_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Trigger_Source);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureTriggerSource", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureTriggerSource_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Trigger_Source);
            public static int ConfigureTriggerSource(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Trigger_Source)
            {
                if (Is64BitProcess)
                    return ConfigureTriggerSource_64(Instrument_Handle, Trigger_Source);
                else
                    return ConfigureTriggerSource_32(Instrument_Handle, Trigger_Source);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureInternalTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureInternalTrigger_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Source_Channel_Name, int Slope);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureInternalTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureInternalTrigger_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Source_Channel_Name, int Slope);
            public static int ConfigureInternalTrigger(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Source_Channel_Name, int Slope)
            {
                if (Is64BitProcess)
                    return ConfigureInternalTrigger_64(Instrument_Handle, Source_Channel_Name, Slope);
                else
                    return ConfigureInternalTrigger_32(Instrument_Handle, Source_Channel_Name, Slope);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureInternalTriggerLevel", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureInternalTriggerLevel_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, double Trigger_Level);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureInternalTriggerLevel", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureInternalTriggerLevel_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, double Trigger_Level);
            public static int ConfigureInternalTriggerLevel(System.Runtime.InteropServices.HandleRef Instrument_Handle, double Trigger_Level)
            {
                if (Is64BitProcess)
                    return ConfigureInternalTriggerLevel_64(Instrument_Handle, Trigger_Level);
                else
                    return ConfigureInternalTriggerLevel_32(Instrument_Handle, Trigger_Level);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureExternalTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureExternalTrigger_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Source_Channel_Name, int Slope);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureExternalTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureExternalTrigger_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Source_Channel_Name, int Slope);
            public static int ConfigureExternalTrigger(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Source_Channel_Name, int Slope)
            {
                if (Is64BitProcess)
                    return ConfigureExternalTrigger_64(Instrument_Handle, Source_Channel_Name, Slope);
                else
                    return ConfigureExternalTrigger_32(Instrument_Handle, Source_Channel_Name, Slope);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureTriggerDelay", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureTriggerDelay_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, ushort Trigger_Delay_Enabled, double Trigger_Delay_Time);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureTriggerDelay", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureTriggerDelay_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, ushort Trigger_Delay_Enabled, double Trigger_Delay_Time);
            public static int ConfigureTriggerDelay(System.Runtime.InteropServices.HandleRef Instrument_Handle, ushort Trigger_Delay_Enabled, double Trigger_Delay_Time)
            {
                if (Is64BitProcess)
                    return ConfigureTriggerDelay_64(Instrument_Handle, Trigger_Delay_Enabled, Trigger_Delay_Time);
                else
                    return ConfigureTriggerDelay_32(Instrument_Handle, Trigger_Delay_Enabled, Trigger_Delay_Time);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureTriggerNoiseImmunity", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureTriggerNoiseImmunity_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, ushort Trigger_Immunity_Enabled, int Trigger_Immunity_Factor);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureTriggerNoiseImmunity", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureTriggerNoiseImmunity_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, ushort Trigger_Immunity_Enabled, int Trigger_Immunity_Factor);
            public static int ConfigureTriggerNoiseImmunity(System.Runtime.InteropServices.HandleRef Instrument_Handle, ushort Trigger_Immunity_Enabled, int Trigger_Immunity_Factor)
            {
                if (Is64BitProcess)
                    return ConfigureTriggerNoiseImmunity_64(Instrument_Handle, Trigger_Immunity_Enabled, Trigger_Immunity_Factor);
                else
                    return ConfigureTriggerNoiseImmunity_32(Instrument_Handle, Trigger_Immunity_Enabled, Trigger_Immunity_Factor);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureTimeSlot", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureTimeSlot_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Slot_Count, double Slot_Width);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureTimeSlot", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureTimeSlot_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Slot_Count, double Slot_Width);
            public static int ConfigureTimeSlot(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Slot_Count, double Slot_Width)
            {
                if (Is64BitProcess)
                    return ConfigureTimeSlot_64(Instrument_Handle, Channel_Name, Slot_Count, Slot_Width);
                else
                    return ConfigureTimeSlot_32(Instrument_Handle, Channel_Name, Slot_Count, Slot_Width);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureTimeSlotExclusion", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureTimeSlotExclusion_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, ushort Exclusion_Enabled, double Exclusion_Time_For_Slot_Start, double Exclusion_Time_For_Slot_End);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureTimeSlotExclusion", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureTimeSlotExclusion_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, ushort Exclusion_Enabled, double Exclusion_Time_For_Slot_Start, double Exclusion_Time_For_Slot_End);
            public static int ConfigureTimeSlotExclusion(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, ushort Exclusion_Enabled, double Exclusion_Time_For_Slot_Start, double Exclusion_Time_For_Slot_End)
            {
                if (Is64BitProcess)
                    return ConfigureTimeSlotExclusion_64(Instrument_Handle, Channel_Name, Exclusion_Enabled, Exclusion_Time_For_Slot_Start, Exclusion_Time_For_Slot_End);
                else
                    return ConfigureTimeSlotExclusion_32(Instrument_Handle, Channel_Name, Exclusion_Enabled, Exclusion_Time_For_Slot_Start, Exclusion_Time_For_Slot_End);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureScope", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureScope_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, double Scope_Record_Length, int Points_Per_Record);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureScope", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureScope_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, double Scope_Record_Length, int Points_Per_Record);
            public static int ConfigureScope(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, double Scope_Record_Length, int Points_Per_Record)
            {
                if (Is64BitProcess)
                    return ConfigureScope_64(Instrument_Handle, Channel_Name, Scope_Record_Length, Points_Per_Record);
                else
                    return ConfigureScope_32(Instrument_Handle, Channel_Name, Scope_Record_Length, Points_Per_Record);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureScopeGate", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureScopeGate_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, ushort Gate_Enabled, double Gate_Start_Time, double Gate_End_Time);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureScopeGate", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureScopeGate_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, ushort Gate_Enabled, double Gate_Start_Time, double Gate_End_Time);
            public static int ConfigureScopeGate(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, ushort Gate_Enabled, double Gate_Start_Time, double Gate_End_Time)
            {
                if (Is64BitProcess)
                    return ConfigureScopeGate_64(Instrument_Handle, Channel_Name, Gate_Enabled, Gate_Start_Time, Gate_End_Time);
                else
                    return ConfigureScopeGate_32(Instrument_Handle, Channel_Name, Gate_Enabled, Gate_Start_Time, Gate_End_Time);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureScopeFence", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureScopeFence_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, ushort Fence_Enabled, double Fence_Start_Time, double Fence_End_Time);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureScopeFence", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureScopeFence_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, ushort Fence_Enabled, double Fence_Start_Time, double Fence_End_Time);
            public static int ConfigureScopeFence(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, ushort Fence_Enabled, double Fence_Start_Time, double Fence_End_Time)
            {
                if (Is64BitProcess)
                    return ConfigureScopeFence_64(Instrument_Handle, Channel_Name, Fence_Enabled, Fence_Start_Time, Fence_End_Time);
                else
                    return ConfigureScopeFence_32(Instrument_Handle, Channel_Name, Fence_Enabled, Fence_Start_Time, Fence_End_Time);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_Zero", CallingConvention = CallingConvention.StdCall)]
            public static extern int Zero_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_Zero", CallingConvention = CallingConvention.StdCall)]
            public static extern int Zero_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name);
            public static int Zero(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name)
            {
                if (Is64BitProcess)
                    return Zero_64(Instrument_Handle, Channel_Name);
                else
                    return Zero_32(Instrument_Handle, Channel_Name);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ZeroAllChannels", CallingConvention = CallingConvention.StdCall)]
            public static extern int ZeroAllChannels_32(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ZeroAllChannels", CallingConvention = CallingConvention.StdCall)]
            public static extern int ZeroAllChannels_64(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            public static int ZeroAllChannels(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return ZeroAllChannels_64(Instrument_Handle);
                else
                    return ZeroAllChannels_32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_IsZeroComplete", CallingConvention = CallingConvention.StdCall)]
            public static extern int IsZeroComplete_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Zero_Status);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_IsZeroComplete", CallingConvention = CallingConvention.StdCall)]
            public static extern int IsZeroComplete_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Zero_Status);
            public static int IsZeroComplete(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Zero_Status)
            {
                if (Is64BitProcess)
                    return IsZeroComplete_64(Instrument_Handle, out  Zero_Status);
                else
                    return IsZeroComplete_32(Instrument_Handle, out  Zero_Status);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_Read", CallingConvention = CallingConvention.StdCall)]
            public static extern int Read_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Max_Time_Millisecond, out double Result);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_Read", CallingConvention = CallingConvention.StdCall)]
            public static extern int Read_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Max_Time_Millisecond, out double Result);
            public static int Read(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Max_Time_Millisecond, out double Result)
            {
                if (Is64BitProcess)
                    return Read_64(Instrument_Handle, Max_Time_Millisecond, out  Result);
                else
                    return Read_32(Instrument_Handle, Max_Time_Millisecond, out  Result);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ReadTimeSlotData", CallingConvention = CallingConvention.StdCall)]
            public static extern int ReadTimeSlotData_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Slot_Data_Size, int Max_Time_Millisecond, [In, Out] double[] Slot_Data, out int Actual_Points);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ReadTimeSlotData", CallingConvention = CallingConvention.StdCall)]
            public static extern int ReadTimeSlotData_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Slot_Data_Size, int Max_Time_Millisecond, [In, Out] double[] Slot_Data, out int Actual_Points);
            public static int ReadTimeSlotData(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Slot_Data_Size, int Max_Time_Millisecond, [In, Out] double[] Slot_Data, out int Actual_Points)
            {
                if (Is64BitProcess)
                    return ReadTimeSlotData_64(Instrument_Handle, Channel_Name, Slot_Data_Size, Max_Time_Millisecond, Slot_Data, out  Actual_Points);
                else
                    return ReadTimeSlotData_32(Instrument_Handle, Channel_Name, Slot_Data_Size, Max_Time_Millisecond, Slot_Data, out  Actual_Points);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ReadScopeData", CallingConvention = CallingConvention.StdCall)]
            public static extern int ReadScopeData_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Record_Buffer_Size, int Max_Time_Millisecond, [In, Out] double[] Record_Buffer, out int Actual_Points);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ReadScopeData", CallingConvention = CallingConvention.StdCall)]
            public static extern int ReadScopeData_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Record_Buffer_Size, int Max_Time_Millisecond, [In, Out] double[] Record_Buffer, out int Actual_Points);
            public static int ReadScopeData(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Record_Buffer_Size, int Max_Time_Millisecond, [In, Out] double[] Record_Buffer, out int Actual_Points)
            {
                if (Is64BitProcess)
                    return ReadScopeData_64(Instrument_Handle, Channel_Name, Record_Buffer_Size, Max_Time_Millisecond, Record_Buffer, out  Actual_Points);
                else
                    return ReadScopeData_32(Instrument_Handle, Channel_Name, Record_Buffer_Size, Max_Time_Millisecond, Record_Buffer, out  Actual_Points);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_Initiate", CallingConvention = CallingConvention.StdCall)]
            public static extern int Initiate_32(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_Initiate", CallingConvention = CallingConvention.StdCall)]
            public static extern int Initiate_64(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            public static int Initiate(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return Initiate_64(Instrument_Handle);
                else
                    return Initiate_32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_IsMeasurementComplete", CallingConvention = CallingConvention.StdCall)]
            public static extern int IsMeasurementComplete_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Measurement_Status);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_IsMeasurementComplete", CallingConvention = CallingConvention.StdCall)]
            public static extern int IsMeasurementComplete_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Measurement_Status);
            public static int IsMeasurementComplete(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Measurement_Status)
            {
                if (Is64BitProcess)
                    return IsMeasurementComplete_64(Instrument_Handle, out  Measurement_Status);
                else
                    return IsMeasurementComplete_32(Instrument_Handle, out  Measurement_Status);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_Fetch", CallingConvention = CallingConvention.StdCall)]
            public static extern int Fetch_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, out double Reading);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_Fetch", CallingConvention = CallingConvention.StdCall)]
            public static extern int Fetch_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, out double Reading);
            public static int Fetch(System.Runtime.InteropServices.HandleRef Instrument_Handle, out double Reading)
            {
                if (Is64BitProcess)
                    return Fetch_64(Instrument_Handle, out  Reading);
                else
                    return Fetch_32(Instrument_Handle, out  Reading);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_QueryResultRangeType", CallingConvention = CallingConvention.StdCall)]
            public static extern int QueryResultRangeType_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, double Measurement_Value, out int Range_Type);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_QueryResultRangeType", CallingConvention = CallingConvention.StdCall)]
            public static extern int QueryResultRangeType_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, double Measurement_Value, out int Range_Type);
            public static int QueryResultRangeType(System.Runtime.InteropServices.HandleRef Instrument_Handle, double Measurement_Value, out int Range_Type)
            {
                if (Is64BitProcess)
                    return QueryResultRangeType_64(Instrument_Handle, Measurement_Value, out  Range_Type);
                else
                    return QueryResultRangeType_32(Instrument_Handle, Measurement_Value, out  Range_Type);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_Abort", CallingConvention = CallingConvention.StdCall)]
            public static extern int Abort_32(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_Abort", CallingConvention = CallingConvention.StdCall)]
            public static extern int Abort_64(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            public static int Abort(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return Abort_64(Instrument_Handle);
                else
                    return Abort_32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_SendSoftwareTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int SendSoftwareTrigger_32(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_SendSoftwareTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int SendSoftwareTrigger_64(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            public static int SendSoftwareTrigger(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return SendSoftwareTrigger_64(Instrument_Handle);
                else
                    return SendSoftwareTrigger_32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_FetchTimeSlotData", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchTimeSlotData_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Slot_Data_Size, [In, Out] double[] Buffer_Data, out int Actual_Points);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_FetchTimeSlotData", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchTimeSlotData_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Slot_Data_Size, [In, Out] double[] Buffer_Data, out int Actual_Points);
            public static int FetchTimeSlotData(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Slot_Data_Size, [In, Out] double[] Buffer_Data, out int Actual_Points)
            {
                if (Is64BitProcess)
                    return FetchTimeSlotData_64(Instrument_Handle, Channel_Name, Slot_Data_Size, Buffer_Data, out  Actual_Points);
                else
                    return FetchTimeSlotData_32(Instrument_Handle, Channel_Name, Slot_Data_Size, Buffer_Data, out  Actual_Points);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_FetchScopeData", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchScopeData_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Record_Buffer_Size, [In, Out] double[] Record_Buffer, out int Actual_Data_Points);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_FetchScopeData", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchScopeData_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Record_Buffer_Size, [In, Out] double[] Record_Buffer, out int Actual_Data_Points);
            public static int FetchScopeData(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Record_Buffer_Size, [In, Out] double[] Record_Buffer, out int Actual_Data_Points)
            {
                if (Is64BitProcess)
                    return FetchScopeData_64(Instrument_Handle, Channel_Name, Record_Buffer_Size, Record_Buffer, out  Actual_Data_Points);
                else
                    return FetchScopeData_32(Instrument_Handle, Channel_Name, Record_Buffer_Size, Record_Buffer, out  Actual_Data_Points);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_reset", CallingConvention = CallingConvention.StdCall)]
            public static extern int reset_32(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_reset", CallingConvention = CallingConvention.StdCall)]
            public static extern int reset_64(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            public static int reset(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return reset_64(Instrument_Handle);
                else
                    return reset_32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ResetWithDefaults", CallingConvention = CallingConvention.StdCall)]
            public static extern int ResetWithDefaults_32(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ResetWithDefaults", CallingConvention = CallingConvention.StdCall)]
            public static extern int ResetWithDefaults_64(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            public static int ResetWithDefaults(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return ResetWithDefaults_64(Instrument_Handle);
                else
                    return ResetWithDefaults_32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_Disable", CallingConvention = CallingConvention.StdCall)]
            public static extern int Disable_32(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_Disable", CallingConvention = CallingConvention.StdCall)]
            public static extern int Disable_64(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            public static int Disable(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return Disable_64(Instrument_Handle);
                else
                    return Disable_32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_self_test", CallingConvention = CallingConvention.StdCall)]
            public static extern int self_test_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, out short Self_Test_Result, System.Text.StringBuilder Self_Test_Message);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_self_test", CallingConvention = CallingConvention.StdCall)]
            public static extern int self_test_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, out short Self_Test_Result, System.Text.StringBuilder Self_Test_Message);
            public static int self_test(System.Runtime.InteropServices.HandleRef Instrument_Handle, out short Self_Test_Result, System.Text.StringBuilder Self_Test_Message)
            {
                if (Is64BitProcess)
                    return self_test_64(Instrument_Handle, out  Self_Test_Result, Self_Test_Message);
                else
                    return self_test_32(Instrument_Handle, out  Self_Test_Result, Self_Test_Message);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_revision_query", CallingConvention = CallingConvention.StdCall)]
            public static extern int revision_query_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, System.Text.StringBuilder Instrument_Driver_Revision, System.Text.StringBuilder Firmware_Revision);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_revision_query", CallingConvention = CallingConvention.StdCall)]
            public static extern int revision_query_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, System.Text.StringBuilder Instrument_Driver_Revision, System.Text.StringBuilder Firmware_Revision);
            public static int revision_query(System.Runtime.InteropServices.HandleRef Instrument_Handle, System.Text.StringBuilder Instrument_Driver_Revision, System.Text.StringBuilder Firmware_Revision)
            {
                if (Is64BitProcess)
                    return revision_query_64(Instrument_Handle, Instrument_Driver_Revision, Firmware_Revision);
                else
                    return revision_query_32(Instrument_Handle, Instrument_Driver_Revision, Firmware_Revision);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_error_query", CallingConvention = CallingConvention.StdCall)]
            public static extern int error_query_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Error_Code, System.Text.StringBuilder Error_Message);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_error_query", CallingConvention = CallingConvention.StdCall)]
            public static extern int error_query_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Error_Code, System.Text.StringBuilder Error_Message);
            public static int error_query(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Error_Code, System.Text.StringBuilder Error_Message)
            {
                if (Is64BitProcess)
                    return error_query_64(Instrument_Handle, out  Error_Code, Error_Message);
                else
                    return error_query_32(Instrument_Handle, out  Error_Code, Error_Message);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_InvalidateAllAttributes", CallingConvention = CallingConvention.StdCall)]
            public static extern int InvalidateAllAttributes_32(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_InvalidateAllAttributes", CallingConvention = CallingConvention.StdCall)]
            public static extern int InvalidateAllAttributes_64(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            public static int InvalidateAllAttributes(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return InvalidateAllAttributes_64(Instrument_Handle);
                else
                    return InvalidateAllAttributes_32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_GetNextCoercionRecord", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetNextCoercionRecord_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Buffer_Size, System.Text.StringBuilder Coercion_Record);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_GetNextCoercionRecord", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetNextCoercionRecord_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Buffer_Size, System.Text.StringBuilder Coercion_Record);
            public static int GetNextCoercionRecord(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Buffer_Size, System.Text.StringBuilder Coercion_Record)
            {
                if (Is64BitProcess)
                    return GetNextCoercionRecord_64(Instrument_Handle, Buffer_Size, Coercion_Record);
                else
                    return GetNextCoercionRecord_32(Instrument_Handle, Buffer_Size, Coercion_Record);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_GetNextInterchangeWarning", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetNextInterchangeWarning_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Buffer_Size, System.Text.StringBuilder Interchange_Warning);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_GetNextInterchangeWarning", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetNextInterchangeWarning_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Buffer_Size, System.Text.StringBuilder Interchange_Warning);
            public static int GetNextInterchangeWarning(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Buffer_Size, System.Text.StringBuilder Interchange_Warning)
            {
                if (Is64BitProcess)
                    return GetNextInterchangeWarning_64(Instrument_Handle, Buffer_Size, Interchange_Warning);
                else
                    return GetNextInterchangeWarning_32(Instrument_Handle, Buffer_Size, Interchange_Warning);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ClearInterchangeWarnings", CallingConvention = CallingConvention.StdCall)]
            public static extern int ClearInterchangeWarnings_32(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ClearInterchangeWarnings", CallingConvention = CallingConvention.StdCall)]
            public static extern int ClearInterchangeWarnings_64(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            public static int ClearInterchangeWarnings(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return ClearInterchangeWarnings_64(Instrument_Handle);
                else
                    return ClearInterchangeWarnings_32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ResetInterchangeCheck", CallingConvention = CallingConvention.StdCall)]
            public static extern int ResetInterchangeCheck_32(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ResetInterchangeCheck", CallingConvention = CallingConvention.StdCall)]
            public static extern int ResetInterchangeCheck_64(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            public static int ResetInterchangeCheck(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return ResetInterchangeCheck_64(Instrument_Handle);
                else
                    return ResetInterchangeCheck_32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_close", CallingConvention = CallingConvention.StdCall)]
            public static extern int close_32(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_close", CallingConvention = CallingConvention.StdCall)]
            public static extern int close_64(System.Runtime.InteropServices.HandleRef Instrument_Handle);
            public static int close(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return close_64(Instrument_Handle);
                else
                    return close_32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_error_message", CallingConvention = CallingConvention.StdCall)]
            public static extern int error_message_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Error_Code, System.Text.StringBuilder Error_Message_2);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_error_message", CallingConvention = CallingConvention.StdCall)]
            public static extern int error_message_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Error_Code, System.Text.StringBuilder Error_Message_2);
            public static int error_message(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Error_Code, System.Text.StringBuilder Error_Message_2)
            {
                if (Is64BitProcess)
                    return error_message_64(Instrument_Handle, Error_Code, Error_Message_2);
                else
                    return error_message_32(Instrument_Handle, Error_Code, Error_Message_2);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_GetAttributeViInt32", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViInt32_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out int Attribute_Value);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_GetAttributeViInt32", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViInt32_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out int Attribute_Value);
            public static int GetAttributeViInt32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out int Attribute_Value)
            {
                if (Is64BitProcess)
                    return GetAttributeViInt32_64(Instrument_Handle, Channel_Name, Attribute_ID, out  Attribute_Value);
                else
                    return GetAttributeViInt32_32(Instrument_Handle, Channel_Name, Attribute_ID, out  Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_GetAttributeViReal64", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViReal64_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out double Attribute_Value);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_GetAttributeViReal64", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViReal64_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out double Attribute_Value);
            public static int GetAttributeViReal64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out double Attribute_Value)
            {
                if (Is64BitProcess)
                    return GetAttributeViReal64_64(Instrument_Handle, Channel_Name, Attribute_ID, out  Attribute_Value);
                else
                    return GetAttributeViReal64_32(Instrument_Handle, Channel_Name, Attribute_ID, out  Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_GetAttributeViString", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViString_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, int Buffer_Size, System.Text.StringBuilder Attribute_Value);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_GetAttributeViString", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViString_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, int Buffer_Size, System.Text.StringBuilder Attribute_Value);
            public static int GetAttributeViString(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, int Buffer_Size, System.Text.StringBuilder Attribute_Value)
            {
                if (Is64BitProcess)
                    return GetAttributeViString_64(Instrument_Handle, Channel_Name, Attribute_ID, Buffer_Size, Attribute_Value);
                else
                    return GetAttributeViString_32(Instrument_Handle, Channel_Name, Attribute_ID, Buffer_Size, Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_GetAttributeViBoolean", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViBoolean_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out ushort Attribute_Value);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_GetAttributeViBoolean", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViBoolean_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out ushort Attribute_Value);
            public static int GetAttributeViBoolean(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out ushort Attribute_Value)
            {
                if (Is64BitProcess)
                    return GetAttributeViBoolean_64(Instrument_Handle, Channel_Name, Attribute_ID, out  Attribute_Value);
                else
                    return GetAttributeViBoolean_32(Instrument_Handle, Channel_Name, Attribute_ID, out  Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_GetAttributeViSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViSession_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out System.Runtime.InteropServices.HandleRef Attribute_Value);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_GetAttributeViSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViSession_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out System.Runtime.InteropServices.HandleRef Attribute_Value);
            public static int GetAttributeViSession(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out System.Runtime.InteropServices.HandleRef Attribute_Value)
            {
                if (Is64BitProcess)
                    return GetAttributeViSession_64(Instrument_Handle, Channel_Name, Attribute_ID, out  Attribute_Value);
                else
                    return GetAttributeViSession_32(Instrument_Handle, Channel_Name, Attribute_ID, out  Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_SetAttributeViInt32", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViInt32_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, int Attribute_Value);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_SetAttributeViInt32", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViInt32_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, int Attribute_Value);
            public static int SetAttributeViInt32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, int Attribute_Value)
            {
                if (Is64BitProcess)
                    return SetAttributeViInt32_64(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
                else
                    return SetAttributeViInt32_32(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_SetAttributeViReal64", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViReal64_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, double Attribute_Value);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_SetAttributeViReal64", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViReal64_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, double Attribute_Value);
            public static int SetAttributeViReal64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, double Attribute_Value)
            {
                if (Is64BitProcess)
                    return SetAttributeViReal64_64(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
                else
                    return SetAttributeViReal64_32(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_SetAttributeViString", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViString_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, string Attribute_Value);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_SetAttributeViString", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViString_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, string Attribute_Value);
            public static int SetAttributeViString(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, string Attribute_Value)
            {
                if (Is64BitProcess)
                    return SetAttributeViString_64(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
                else
                    return SetAttributeViString_32(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_SetAttributeViBoolean", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViBoolean_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, ushort Attribute_Value);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_SetAttributeViBoolean", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViBoolean_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, ushort Attribute_Value);
            public static int SetAttributeViBoolean(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, ushort Attribute_Value)
            {
                if (Is64BitProcess)
                    return SetAttributeViBoolean_64(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
                else
                    return SetAttributeViBoolean_32(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_SetAttributeViSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViSession_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, System.Runtime.InteropServices.HandleRef Attribute_Value);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_SetAttributeViSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViSession_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, System.Runtime.InteropServices.HandleRef Attribute_Value);
            public static int SetAttributeViSession(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, System.Runtime.InteropServices.HandleRef Attribute_Value)
            {
                if (Is64BitProcess)
                    return SetAttributeViSession_64(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
                else
                    return SetAttributeViSession_32(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_GetError", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetError_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Error_Code, int Buffer_Size, System.Text.StringBuilder Description);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_GetError", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetError_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Error_Code, int Buffer_Size, System.Text.StringBuilder Description);
            public static int GetError(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Error_Code, int Buffer_Size, System.Text.StringBuilder Description)
            {
                if (Is64BitProcess)
                    return GetError_64(Instrument_Handle, out  Error_Code, Buffer_Size, Description);
                else
                    return GetError_32(Instrument_Handle, out  Error_Code, Buffer_Size, Description);
            }

            public static int TestForError(System.Runtime.InteropServices.HandleRef handle, int status)
            {
                if ((status < 0))
                {
                    PInvoke.ThrowError(handle, status);
                }
                return status;
            }

            public static int ThrowError(System.Runtime.InteropServices.HandleRef handle, int code)
            {
                int status;
                int size = PInvoke.GetError(handle, out status, 0, null);
                System.Text.StringBuilder msg = new System.Text.StringBuilder();
                if ((size >= 0))
                {
                    msg.Capacity = size;
                    PInvoke.GetError(handle, out status, size, msg);
                }
                throw new System.Runtime.InteropServices.ExternalException(msg.ToString(), code);
            }

            // Added in 15.0
            [DllImport(nativeDllName32, EntryPoint = "ni568x_ConfigureTriggerHysteresis", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureTriggerHysteresis_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, ushort Trigger_Hysteresis_Enabled, double Trigger_Hysteresis);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ConfigureTriggerHysteresis", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureTriggerHysteresis_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, ushort Trigger_Hysteresis_Enabled, double Trigger_Hysteresis);
            public static int ConfigureTriggerHysteresis(System.Runtime.InteropServices.HandleRef Instrument_Handle, ushort Trigger_Hysteresis_Enabled, double Trigger_Hysteresis)
            {
                if (Is64BitProcess)
                    return ConfigureTriggerHysteresis_64(Instrument_Handle, Trigger_Hysteresis_Enabled, Trigger_Hysteresis);
                else
                    return ConfigureTriggerHysteresis_32(Instrument_Handle, Trigger_Hysteresis_Enabled, Trigger_Hysteresis);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_ReadArray", CallingConvention = CallingConvention.StdCall)]
            public static extern int ReadArray_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Buffer_Size, int Max_Time_Millisecond, out double Power);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_ReadArray", CallingConvention = CallingConvention.StdCall)]
            public static extern int ReadArray_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Buffer_Size, int Max_Time_Millisecond, out double Power);
            public static int ReadArray(System.Runtime.InteropServices.HandleRef Instrument_Handle,out int Buffer_Size, int Max_Time_Millisecond, out double Power)
            {
                if (Is64BitProcess)
                    return ReadArray_64(Instrument_Handle, out Buffer_Size, Max_Time_Millisecond, out Power);
                else
                    return ReadArray_32(Instrument_Handle, out Buffer_Size, Max_Time_Millisecond, out Power);
            }

            [DllImport(nativeDllName32, EntryPoint = "ni568x_FetchArray", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchArray_32(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Buffer_Size, out double Power);
            [DllImport(nativeDllName64, EntryPoint = "ni568x_FetchArray", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchArray_64(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Buffer_Size, out double Power);
            public static int FetchArray(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Buffer_Size, out double Power)
            {
                if (Is64BitProcess)
                    return FetchArray_64(Instrument_Handle, out Buffer_Size, out Power);
                else
                    return FetchArray_32(Instrument_Handle, out Buffer_Size, out Power);
            }


        }
    }
    /// <summary>
    /// 
    /// </summary>
    public class ni568xConstants
    {
        /// <summary>
        /// 
        /// </summary>
        public const int ContinuousMode = 10000;
        /// <summary>
        /// 
        /// </summary>
        public const int TimeSlotMode = 20000;
        /// <summary>
        /// 
        /// </summary>
        public const int ScopeMode = 30000;
        /// <summary>
        /// 
        /// </summary>
        public const int Dbm = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int Watts = 4;
        /// <summary>
        /// 
        /// </summary>
        public const int Mwatts = 1001;
        /// <summary>
        /// 
        /// </summary>
        public const int Uwatts = 1002;
        /// <summary>
        /// 
        /// </summary>
        public const int None = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int Immediate = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int External = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int Internal = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int SoftwareTrig = 4;
        /// <summary>
        /// 
        /// </summary>
        public const int Positive = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int Negative = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int Low = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int High = 1;
    }
    /// <summary>
    /// 
    /// </summary>
    public enum ni568xProperties
    {

        /// <summary>
        /// System.Boolean
        /// </summary>
        RangeCheck = 1050002,

        /// <summary>
        /// System.Boolean
        /// </summary>
        QueryInstrumentStatus = 1050003,

        /// <summary>
        /// System.Boolean
        /// </summary>
        Cache = 1050004,

        /// <summary>
        /// System.Boolean
        /// </summary>
        Simulate = 1050005,

        /// <summary>
        /// System.Boolean
        /// </summary>
        RecordCoercions = 1050006,

        /// <summary>
        /// System.Boolean
        /// </summary>
        InterchangeCheck = 1050021,

        /// <summary>
        /// System.String
        /// </summary>
        SpecificDriverDescription = 1050514,

        /// <summary>
        /// System.String
        /// </summary>
        SpecificDriverPrefix = 1050302,

        /// <summary>
        /// System.String
        /// </summary>
        SpecificDriverVendor = 1050513,

        /// <summary>
        /// System.String
        /// </summary>
        SpecificDriverRevision = 1050551,

        /// <summary>
        /// System.Int32
        /// </summary>
        SpecificDriverClassSpecMajorVersion = 1050515,

        /// <summary>
        /// System.Int32
        /// </summary>
        SpecificDriverClassSpecMinorVersion = 1050516,

        /// <summary>
        /// System.String
        /// </summary>
        SupportedInstrumentModels = 1050327,

        /// <summary>
        /// System.String
        /// </summary>
        GroupCapabilities = 1050401,

        /// <summary>
        /// System.String
        /// </summary>
        InstrumentManufacturer = 1050511,

        /// <summary>
        /// System.String
        /// </summary>
        InstrumentModel = 1050512,

        /// <summary>
        /// System.String
        /// </summary>
        InstrumentFirmwareRevision = 1050510,

        /// <summary>
        /// System.String
        /// </summary>
        LogicalName = 1050305,

        /// <summary>
        /// System.String
        /// </summary>
        IoResourceDescriptor = 1050304,

        /// <summary>
        /// System.String
        /// </summary>
        DriverSetup = 1050007,

        /// <summary>
        /// System.Double
        /// </summary>
        ApertureTime = 1150004,

        /// <summary>
        /// System.Int32
        /// </summary>
        ApertureTimeMode = 1150003,

        /// <summary>
        /// System.Double
        /// </summary>
        CorrectionFrequency = 1250004,

        /// <summary>
        /// System.Double
        /// </summary>
        Offset = 1250005,

        /// <summary>
        /// System.Boolean
        /// </summary>
        RangeAutoEnabled = 1250002,

        /// <summary>
        /// System.Int32
        /// </summary>
        Units = 1250001,

        /// <summary>
        /// System.Double
        /// </summary>
        RangeLower = 1250101,

        /// <summary>
        /// System.Double
        /// </summary>
        RangeUpper = 1250102,

        /// <summary>
        /// System.Int32
        /// </summary>
        TriggerSource = 1250201,

        /// <summary>
        /// System.Boolean
        /// </summary>
        TriggerDelayEnabled = 1150121,

        /// <summary>
        /// System.Double
        /// </summary>
        TriggerDelay = 1150120,

        /// <summary>
        /// System.Boolean
        /// </summary>
        TriggerNoiseImmunityEnabled = 1150123,

        /// <summary>
        /// System.Int32
        /// </summary>
        TriggerNoiseImmunity = 1150122,

        /// <summary>
        /// System.String
        /// </summary>
        InternalTriggerEventSource = 1250251,

        /// <summary>
        /// System.Int32
        /// </summary>
        InternalTriggerSlope = 1250253,

        /// <summary>
        /// System.Double
        /// </summary>
        InternalTriggerLevel = 1250252,

        /// <summary>
        /// System.String
        /// </summary>
        ExternalTriggerEventSource = 1150106,

        /// <summary>
        /// System.Int32
        /// </summary>
        ExternalTriggerSlope = 1150107,

        /// <summary>
        /// System.Boolean
        /// </summary>
        DutyCycleCorrectionEnabled = 1250401,

        /// <summary>
        /// System.Double
        /// </summary>
        DutyCycleCorrection = 1250402,

        /// <summary>
        /// System.Boolean
        /// </summary>
        AveragingAutoEnabled = 1250003,

        /// <summary>
        /// System.Double
        /// </summary>
        AveragingAutoResolution = 1150007,

        /// <summary>
        /// System.Int32
        /// </summary>
        AveragingAutoSource = 1150008,

        /// <summary>
        /// System.Int32
        /// </summary>
        AveragingCount = 1250301,

        /// <summary>
        /// System.Int32
        /// </summary>
        TimeSlotCount = 1150200,

        /// <summary>
        /// System.Double
        /// </summary>
        TimeSlotWidth = 1150201,

        /// <summary>
        /// System.Boolean
        /// </summary>
        TimeSlotExclusionEnabled = 1150204,

        /// <summary>
        /// System.Double
        /// </summary>
        TimeSlotExclusionStart = 1150202,

        /// <summary>
        /// System.Double
        /// </summary>
        TimeSlotExclusionEnd = 1150203,

        /// <summary>
        /// System.Double
        /// </summary>
        ScopeRecordLength = 1150300,

        /// <summary>
        /// System.Int32
        /// </summary>
        ScopeRecordPoints = 1150301,

        /// <summary>
        /// System.Boolean
        /// </summary>
        ScopeGateEnabled = 1150304,

        /// <summary>
        /// System.Double
        /// </summary>
        ScopeGateStart = 1150302,

        /// <summary>
        /// System.Double
        /// </summary>
        ScopeGateEnd = 1150303,

        /// <summary>
        /// System.Boolean
        /// </summary>
        ScopeFenceEnabled = 1150307,

        /// <summary>
        /// System.Double
        /// </summary>
        ScopeFenceStart = 1150305,

        /// <summary>
        /// System.Double
        /// </summary>
        ScopeFenceEnd = 1150306,

        /// <summary>
        /// System.Double
        /// </summary>
        ScopeGateAveragePower = 1150320,

        /// <summary>
        /// System.Double
        /// </summary>
        ScopeGatePeakPower = 1150321,

        /// <summary>
        /// System.Double
        /// </summary>
        ScopeGateMinimumPower = 1150322,

        /// <summary>
        /// System.Double
        /// </summary>
        ScopeGateCrestFactor = 1150323,

        /// <summary>
        /// System.String
        /// </summary>
        ExternalCalibrationDate = 1150005,

        /// <summary>
        /// System.String
        /// </summary>
        InstrumentSerialNumber = 1150002,

        // Added in 15.0

        /// <summary>
        /// 
        /// </summary>
        EnhancedModulationModeEnabled = 1150009,

        /// <summary>
        /// 
        /// </summary>
        BufferSize = 1150010,

        /// <summary>
        /// 
        /// </summary>
        TriggerHysteresis = 1150124,

        /// <summary>
        /// 
        /// </summary>
        TriggerHysteresisEnabled = 1150125,


    }
}
